{
  "version": 3,
  "sources": ["../../paneforge/dist/internal/utils/lifecycle.js", "../../paneforge/dist/internal/utils/store.js", "../../paneforge/dist/internal/utils/style.js", "../../paneforge/dist/internal/utils/aria.js", "../../paneforge/node_modules/nanoid/non-secure/index.js", "../../paneforge/dist/internal/utils/id.js", "../../paneforge/dist/internal/constants.js", "../../paneforge/dist/internal/utils/storage.js", "../../paneforge/dist/internal/utils/object.js", "../../paneforge/dist/internal/utils/chain.js", "../../paneforge/dist/internal/utils/event.js", "../../paneforge/dist/internal/utils/compare.js", "../../paneforge/dist/internal/utils/assert.js", "../../paneforge/dist/internal/utils/resize.js", "../../paneforge/dist/internal/utils/adjust-layout.js", "../../paneforge/dist/internal/utils/is.js", "../../paneforge/dist/internal/paneforge.js", "../../paneforge/dist/components/ctx.js", "../../paneforge/dist/components/pane-group.svelte", "../../paneforge/dist/components/pane.svelte", "../../paneforge/dist/components/pane-resizer.js", "../../paneforge/dist/components/pane-resizer.svelte"],
  "sourcesContent": ["import { onDestroy } from \"svelte\";\n/**\n * Safely calls `onDestroy` and catches any errors that occur.\n */\nexport function safeOnDestroy(fn) {\n    try {\n        onDestroy(fn);\n    }\n    catch {\n        return fn();\n    }\n}\n", "import { isBrowser, safeOnDestroy } from \"./index.js\";\nimport { derived, writable, } from \"svelte/store\";\n/**\n * A utility function that creates a derived store that automatically\n * unsubscribes from its dependencies.\n *\n * Originally written by @tglide for use in Melt UI. <3\n *\n * @template S - The type of the stores object\n * @template T - The type of the derived store\n * @param stores - The stores object to derive from\n * @param fn - The function to derive the store from\n * @returns A derived store that automatically unsubscribes from its dependencies\n */\nexport function derivedWithUnsubscribe(stores, fn) {\n    let unsubscribers = [];\n    const onUnsubscribe = (cb) => {\n        unsubscribers.push(cb);\n    };\n    const unsubscribe = () => {\n        // Call all of the unsubscribe functions from the previous run of the function\n        unsubscribers.forEach((fn) => fn());\n        // Clear the list of unsubscribe functions\n        unsubscribers = [];\n    };\n    const derivedStore = derived(stores, ($storeValues) => {\n        unsubscribe();\n        return fn($storeValues, onUnsubscribe);\n    });\n    safeOnDestroy(unsubscribe);\n    const subscribe = (...args) => {\n        const unsub = derivedStore.subscribe(...args);\n        return () => {\n            unsub();\n            unsubscribe();\n        };\n    };\n    return {\n        ...derivedStore,\n        subscribe,\n    };\n}\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * Originally written by @tglide for use in Melt UI. <3\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function clientEffect(stores, fn) {\n    if (!isBrowser)\n        return () => { };\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const unsub = derivedWithUnsubscribe(stores, (stores, onUnsubscribe) => {\n        return {\n            stores,\n            onUnsubscribe,\n        };\n    }).subscribe(({ stores, onUnsubscribe }) => {\n        const returned = fn(stores);\n        // If the function returns a cleanup function, call it when the effect is unsubscribed\n        if (returned) {\n            onUnsubscribe(returned);\n        }\n    });\n    // Automatically unsubscribe the effect when the component is destroyed\n    safeOnDestroy(unsub);\n    return unsub;\n}\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = writable(value);\n    });\n    return result;\n}\n/**\n * Returns a function that can be used to update the values of options\n * in a store based on the modification of a prop.\n */\nexport function getOptionUpdater(options) {\n    return function (key, value) {\n        if (value === undefined)\n            return;\n        const store = options[key];\n        if (store) {\n            store.set(value);\n        }\n    };\n}\n", "/**\n * A utility function that converts a style object to a string,\n * which can be used as the value of the `style` attribute for\n * an element.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, \"\");\n}\n/* Global cursor state */\nlet currentState = null;\n/* Global cursor element */\nlet element = null;\n/**\n * Returns the cursor style for a given cursor state.\n */\nexport function getCursorStyle(state) {\n    switch (state) {\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\n/**\n * Resets the global cursor style to the default.\n */\nexport function resetGlobalCursorStyle() {\n    if (element === null)\n        return;\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n}\n/**\n * Sets the global cursor style to the given state.\n */\nexport function setGlobalCursorStyle(state) {\n    if (currentState === state)\n        return;\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = document.createElement(\"style\");\n        document.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n/**\n * Computes the flexbox style for a pane given its layout and drag state.\n */\nexport function computePaneFlexBoxStyle({ defaultSize, dragState, layout, paneData, paneIndex, precision = 3, }) {\n    const size = layout[paneIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panes have registered themselves)\n        // To support server rendering, fallback to default size\n        flexGrow = defaultSize ?? \"1\";\n    }\n    else if (paneData.length === 1) {\n        //  Single pane group should always fill full width/height\n        flexGrow = \"1\";\n    }\n    else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return styleToString({\n        \"flex-basis\": 0,\n        \"flex-grow\": flexGrow,\n        \"flex-shrink\": 1,\n        // Without this, pane sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a pane during resize\n        // This avoid edge cases like nested iframes\n        \"pointer-events\": dragState !== null ? \"none\" : undefined,\n    });\n}\n", "/**\n * A utility function that calculates the `aria-valuemax`, `aria-valuemin`,\n * and `aria-valuenow` values for a pane based on its layout and constraints.\n */\nexport function calculateAriaValues({ layout, panesArray, pivotIndices, }) {\n    let currentMinSize = 0;\n    let currentMaxSize = 100;\n    let totalMinSize = 0;\n    let totalMaxSize = 0;\n    const firstIndex = pivotIndices[0];\n    // A pane's effective min/max sizes also need to account for other pane's sizes.\n    for (let i = 0; i < panesArray.length; i++) {\n        const { constraints } = panesArray[i];\n        const { maxSize = 100, minSize = 0 } = constraints;\n        if (i === firstIndex) {\n            currentMinSize = minSize;\n            currentMaxSize = maxSize;\n        }\n        else {\n            totalMinSize += minSize;\n            totalMaxSize += maxSize;\n        }\n    }\n    const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n    const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n    const valueNow = layout[firstIndex];\n    return {\n        valueMax,\n        valueMin,\n        valueNow,\n    };\n}\n", "let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n", "import { nanoid } from \"nanoid/non-secure\";\n/**\n * If an id is provided return it, otherwise generate a new id and return that.\n */\nexport function generateId(idFromProps = null) {\n    if (idFromProps == null)\n        return nanoid(10);\n    return idFromProps;\n}\n", "export const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nexport const PRECISION = 10;\n", "import { get } from \"svelte/store\";\nimport { LOCAL_STORAGE_DEBOUNCE_INTERVAL } from \"../constants.js\";\n/**\n * Initializes the storage object with the appropriate getItem\n *  and setItem functions depending on the environment (browser or not).\n */\nexport function initializeStorage(storageObject) {\n    try {\n        if (typeof localStorage === \"undefined\") {\n            throw new Error(\"localStorage is not supported in this environment\");\n        }\n        storageObject.getItem = (name) => localStorage.getItem(name);\n        storageObject.setItem = (name, value) => localStorage.setItem(name, value);\n    }\n    catch (err) {\n        // eslint-disable-next-line no-console\n        console.error(err);\n        storageObject.getItem = () => null;\n        storageObject.setItem = () => { };\n    }\n}\n/**\n * Returns the key to use for storing the pane group state in local storage.\n */\nfunction getPaneGroupKey(autoSaveId) {\n    return `paneforge:${autoSaveId}`;\n}\n/**\n * Returns a key to use for storing the pane state in local storage.\n * The key is based on the pane order and constraints.\n */\nfunction getPaneKey(panes) {\n    const sortedPaneIds = panes\n        .map((pane) => {\n        const { constraints, id, idIsFromProps, order } = pane;\n        return idIsFromProps\n            ? id\n            : order\n                ? `${order}:${JSON.stringify(constraints)}`\n                : JSON.stringify(constraints);\n    })\n        .sort()\n        .join(\",\");\n    return sortedPaneIds;\n}\n/**\n * Loads the serialized pane group state from local storage.\n * If the state is not found, returns null.\n */\nfunction loadSerializedPaneGroupState(autoSaveId, storage) {\n    try {\n        const paneGroupKey = getPaneGroupKey(autoSaveId);\n        const serialized = storage.getItem(paneGroupKey);\n        const parsed = JSON.parse(serialized || \"\");\n        if (typeof parsed === \"object\" && parsed !== null) {\n            return parsed;\n        }\n    }\n    catch {\n        // noop\n    }\n    return null;\n}\n/**\n * Loads the pane group state from local storage.\n * If the state is not found, returns null.\n */\nexport function loadPaneGroupState(autoSaveId, panes, storage) {\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    const paneKey = getPaneKey(panes);\n    return state[paneKey] || null;\n}\n/**\n * Saves the pane group state to local storage.\n */\nexport function savePaneGroupState(autoSaveId, panes, paneSizesBeforeCollapse, sizes, storage) {\n    const paneGroupKey = getPaneGroupKey(autoSaveId);\n    const paneKey = getPaneKey(panes);\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    state[paneKey] = {\n        expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),\n        layout: sizes,\n    };\n    try {\n        storage.setItem(paneGroupKey, JSON.stringify(state));\n    }\n    catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(error);\n    }\n}\nconst debounceMap = {};\n/**\n * Returns a debounced version of the given function.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const callable = (...args) => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n/**\n * Updates the values in local storage based on the current state of\n * the pane group.\n * This function is debounced to limit the frequency of local storage writes.\n */\nexport function updateStorageValues({ autoSaveId, layout, storage, paneDataArrayStore, paneSizeBeforeCollapseStore, }) {\n    const $paneDataArray = get(paneDataArrayStore);\n    // If this pane has been configured to persist sizing\n    // information, save sizes to local storage.\n    if (layout.length === 0 || layout.length !== $paneDataArray.length)\n        return;\n    let debouncedSave = debounceMap[autoSaveId];\n    // Limit frequency of local storage writes.\n    if (debouncedSave == null) {\n        debouncedSave = debounce(savePaneGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n    }\n    // Clone mutable data before passing to the debounced function,\n    // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n    const clonedPaneDataArray = [...$paneDataArray];\n    const $paneSizeBeforeCollapse = get(paneSizeBeforeCollapseStore);\n    const clonedPaneSizesBeforeCollapse = new Map($paneSizeBeforeCollapse);\n    debouncedSave(autoSaveId, clonedPaneDataArray, clonedPaneSizesBeforeCollapse, layout, storage);\n}\n", "/**\n * Removes all undefined properties from the given object.\n */\nexport function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n", "/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function chain(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\n", "/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\n", "import { PRECISION } from \"../constants.js\";\n/**\n * Compares two numbers for equality with a given fractional precision.\n */\nexport function areNumbersAlmostEqual(actual, expected, fractionDigits = PRECISION) {\n    return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;\n}\n/**\n * Compares two numbers with a given tolerance.\n *\n * @returns `-1` if `actual` is less than `expected`, `0` if they are equal,\n * and `1` if `actual` is greater than `expected`.\n */\nexport function compareNumbersWithTolerance(actual, expected, fractionDigits = PRECISION) {\n    const roundedActual = roundTo(actual, fractionDigits);\n    const roundedExpected = roundTo(expected, fractionDigits);\n    return Math.sign(roundedActual - roundedExpected);\n}\n/**\n * Compares two arrays for equality.\n */\nexport function areArraysEqual(arrA, arrB) {\n    if (arrA.length !== arrB.length)\n        return false;\n    for (let index = 0; index < arrA.length; index++) {\n        if (arrA[index] !== arrB[index])\n            return false;\n    }\n    return true;\n}\n/**\n * Rounds a number to a given number of decimal places.\n */\nfunction roundTo(value, decimals) {\n    return parseFloat(value.toFixed(decimals));\n}\n", "export function assert(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexpectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        // eslint-disable-next-line no-console\n        console.error(message);\n        throw Error(message);\n    }\n}\n", "import { PRECISION } from \"../constants.js\";\nimport { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance } from \"./compare.js\";\n/**\n * Resizes a pane based on its constraints.\n */\nexport function resizePane({ paneConstraints: paneConstraintsArray, paneIndex, initialSize, }) {\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    assert(paneConstraints != null, \"Pane constraints should not be null.\");\n    const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = paneConstraints;\n    let newSize = initialSize;\n    if (compareNumbersWithTolerance(newSize, minSize) < 0) {\n        newSize = getAdjustedSizeForCollapsible(newSize, collapsible, collapsedSize, minSize);\n    }\n    newSize = Math.min(maxSize, newSize);\n    return parseFloat(newSize.toFixed(PRECISION));\n}\n/**\n * Adjusts the size of a pane based on its collapsible state.\n *\n * If the pane is collapsible, the size will be snapped to the collapsed size\n * or the minimum size based on the halfway point.\n */\nfunction getAdjustedSizeForCollapsible(size, collapsible, collapsedSize, minSize) {\n    if (!collapsible)\n        return minSize;\n    // Snap collapsible panes closed or open based on the halfway point.\n    const halfwayPoint = (collapsedSize + minSize) / 2;\n    return compareNumbersWithTolerance(size, halfwayPoint) < 0 ? collapsedSize : minSize;\n}\n", "import { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance, areNumbersAlmostEqual, resizePane, } from \"./index.js\";\n/**\n * Adjusts the layout of panes based on the delta of the resize handle.\n * All units must be in percentages; pixel values should be pre-converted.\n *\n * Credit: https://github.com/bvaughn/react-resizable-panels\n */\nexport function adjustLayoutByDelta({ delta, layout: prevLayout, paneConstraints: paneConstraintsArray, pivotIndices, trigger, }) {\n    if (areNumbersAlmostEqual(delta, 0))\n        return prevLayout;\n    const nextLayout = [...prevLayout];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    let deltaApplied = 0;\n    // A resizing pane affects the panes before or after it.\n    //\n    // A negative delta means the pane(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panes may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the pane(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panes after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the pane from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed pane\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                if (paneConstraints.collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                            //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a pane at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                const { collapsible } = paneConstraints;\n                if (collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panes in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information too–\n        // as an expanding pane might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const maxSafeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: 100,\n            });\n            const delta = maxSafeSize - prevSize;\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= paneConstraintsArray.length) {\n                break;\n            }\n        }\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    }\n    {\n        // Delta added to a pane needs to be subtracted from other panes (within the constraints that those panes allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while (index >= 0 && index < paneConstraintsArray.length) {\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true,\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            }\n            else {\n                index++;\n            }\n        }\n    }\n    // If we were unable to resize any of the panes, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a pane's boundaries\n    if (areNumbersAlmostEqual(deltaApplied, 0)) {\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panes in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = prevLayout[pivotIndex];\n        assert(prevSize != null);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePane({\n            paneConstraints: paneConstraintsArray,\n            paneIndex: pivotIndex,\n            initialSize: unsafeSize,\n        });\n        // Adjust the pivot pane before, but only by the amount that surrounding panes were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one pane caused another one to change collapsed state\n        if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while (index >= 0 && index < paneConstraintsArray.length) {\n                const prevSize = nextLayout[index];\n                assert(prevSize != null);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePane({\n                    paneConstraints: paneConstraintsArray,\n                    paneIndex: index,\n                    initialSize: unsafeSize,\n                });\n                if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (areNumbersAlmostEqual(deltaRemaining, 0))\n                    break;\n                delta > 0 ? index-- : index++;\n            }\n        }\n    }\n    const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n    if (!areNumbersAlmostEqual(totalSize, 100))\n        return prevLayout;\n    return nextLayout;\n}\n", "export const isBrowser = typeof document !== \"undefined\";\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nexport function isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nexport function isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\n", "import { initializeStorage, loadPaneGroupState, resizePane, resetGlobalCursorStyle, setGlobalCursorStyle, updateStorageValues, adjustLayoutByDelta, areNumbersAlmostEqual, areArraysEqual, generateId, removeUndefined, clientEffect, toWritableStores, calculateAriaValues, addEventListener, computePaneFlexBoxStyle, styleToString, isBrowser, isHTMLElement, isKeyDown, isMouseEvent, isTouchEvent, } from \"./utils/index.js\";\nimport { derived, get, writable } from \"svelte/store\";\nimport { assert } from \"./utils/assert.js\";\nimport { onMount } from \"svelte\";\nexport const defaultStorage = {\n    getItem: (name) => {\n        initializeStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value) => {\n        initializeStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    },\n};\nconst defaultProps = {\n    id: null,\n    onLayout: null,\n    keyboardResizeBy: null,\n    autoSaveId: null,\n    direction: \"horizontal\",\n    storage: defaultStorage,\n};\nexport function createPaneForge(props) {\n    const withDefaults = {\n        ...defaultProps,\n        ...removeUndefined(props),\n    };\n    const options = toWritableStores(withDefaults);\n    const { autoSaveId, direction, keyboardResizeBy, storage, onLayout } = options;\n    const groupId = writable(generateId());\n    const dragState = writable(null);\n    const layout = writable([]);\n    const paneDataArray = writable([]);\n    const paneDataArrayChanged = writable(false);\n    const paneIdToLastNotifiedSizeMap = writable({});\n    const paneSizeBeforeCollapseMap = writable(new Map());\n    const prevDelta = writable(0);\n    clientEffect([groupId, layout, paneDataArray], ([$groupId, $layout, $paneDataArray]) => {\n        const unsub = updateResizeHandleAriaValues({\n            groupId: $groupId,\n            layout: $layout,\n            paneDataArray: $paneDataArray,\n        });\n        return unsub;\n    });\n    onMount(() => {\n        const unsub = setResizeHandlerEventListeners();\n        return unsub;\n    });\n    clientEffect([autoSaveId, layout, storage], ([$autoSaveId, $layout, $storage]) => {\n        if (!$autoSaveId)\n            return;\n        updateStorageValues({\n            autoSaveId: $autoSaveId,\n            layout: $layout,\n            storage: $storage,\n            paneDataArrayStore: paneDataArray,\n            paneSizeBeforeCollapseStore: paneSizeBeforeCollapseMap,\n        });\n    });\n    function collapsePane(paneData) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        if (!paneData.constraints.collapsible)\n            return;\n        const paneConstraintsArray = $paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, pivotIndices, } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        assert(paneSize != null);\n        if (paneSize === collapsedSize)\n            return;\n        // Store the size before collapse, which is returned when `expand()` is called\n        paneSizeBeforeCollapseMap.update((curr) => {\n            curr.set(paneData.id, paneSize);\n            return curr;\n        });\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - collapsedSize : collapsedSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        if ($onLayout) {\n            $onLayout(nextLayout);\n        }\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    function getPaneSize(paneData) {\n        const $layout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        const { paneSize } = paneDataHelper($paneDataArray, paneData, $layout);\n        return paneSize;\n    }\n    const getPaneStyle = derived([paneDataArray, layout, dragState], ([$paneDataArray, $layout, $dragState]) => {\n        return (paneData, defaultSize) => {\n            const paneIndex = findPaneDataIndex($paneDataArray, paneData);\n            return computePaneFlexBoxStyle({\n                defaultSize,\n                dragState: $dragState,\n                layout: $layout,\n                paneData: $paneDataArray,\n                paneIndex,\n            });\n        };\n    });\n    function isPaneExpanded(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const $layout = get(layout);\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper($paneDataArray, paneData, $layout);\n        return !collapsible || paneSize > collapsedSize;\n    }\n    function registerPane(paneData) {\n        paneDataArray.update((curr) => {\n            const newArr = [...curr, paneData];\n            newArr.sort((paneA, paneB) => {\n                const orderA = paneA.order;\n                const orderB = paneB.order;\n                if (orderA == null && orderB == null) {\n                    return 0;\n                }\n                else if (orderA == null) {\n                    return -1;\n                }\n                else if (orderB == null) {\n                    return 1;\n                }\n                else {\n                    return orderA - orderB;\n                }\n            });\n            return newArr;\n        });\n        paneDataArrayChanged.set(true);\n    }\n    clientEffect([paneDataArrayChanged], ([$paneDataArrayChanged]) => {\n        if (!$paneDataArrayChanged)\n            return;\n        paneDataArrayChanged.set(false);\n        const $autoSaveId = get(autoSaveId);\n        const $storage = get(storage);\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        // If this pane has been configured to persist sizing information,\n        // default size should be restored from local storage if possible.\n        let unsafeLayout = null;\n        if ($autoSaveId) {\n            const state = loadPaneGroupState($autoSaveId, $paneDataArray, $storage);\n            if (state) {\n                paneSizeBeforeCollapseMap.set(new Map(Object.entries(state.expandToSizes)));\n                unsafeLayout = state.layout;\n            }\n        }\n        if (unsafeLayout == null) {\n            unsafeLayout = getUnsafeDefaultLayout({\n                paneDataArray: $paneDataArray,\n            });\n        }\n        // Validate even saved layouts in case something has changed since last render\n        const nextLayout = validatePaneGroupLayout({\n            layout: unsafeLayout,\n            paneConstraints: $paneDataArray.map((paneData) => paneData.constraints),\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        if ($onLayout) {\n            $onLayout(nextLayout);\n        }\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    });\n    function registerResizeHandle(dragHandleId) {\n        return function resizeHandler(event) {\n            event.preventDefault();\n            const $direction = get(direction);\n            const $dragState = get(dragState);\n            const $groupId = get(groupId);\n            const $keyboardResizeBy = get(keyboardResizeBy);\n            const $prevLayout = get(layout);\n            const $paneDataArray = get(paneDataArray);\n            const { initialLayout } = $dragState ?? {};\n            const pivotIndices = getPivotIndices($groupId, dragHandleId);\n            let delta = getDeltaPercentage(event, dragHandleId, $direction, $dragState, $keyboardResizeBy);\n            if (delta === 0)\n                return;\n            // support RTL\n            const isHorizontal = $direction === \"horizontal\";\n            if (document.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const paneConstraints = $paneDataArray.map((paneData) => paneData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                layout: initialLayout ?? $prevLayout,\n                paneConstraints: paneConstraints,\n                pivotIndices,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\",\n            });\n            const layoutChanged = !areArraysEqual($prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Pane sizes might not change–\n                // but updating cursor in this scenario would cause a flicker.\n                const $prevDelta = get(prevDelta);\n                if ($prevDelta != delta) {\n                    prevDelta.set(delta);\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the pane any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\");\n                        }\n                        else {\n                            setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\");\n                        }\n                    }\n                    else {\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n                    }\n                }\n            }\n            if (layoutChanged) {\n                layout.set(nextLayout);\n                const $onLayout = get(onLayout);\n                if ($onLayout) {\n                    $onLayout(nextLayout);\n                }\n                callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n            }\n        };\n    }\n    function resizePane(paneData, unsafePaneSize) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        const paneConstraintsArr = $paneDataArray.map((paneData) => paneData.constraints);\n        const { paneSize, pivotIndices } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        assert(paneSize != null);\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - unsafePaneSize : unsafePaneSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArr,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        $onLayout?.(nextLayout);\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    function startDragging(dragHandleId, event) {\n        const $direction = get(direction);\n        const $layout = get(layout);\n        const handleElement = getResizeHandleElement(dragHandleId);\n        assert(handleElement);\n        const initialCursorPosition = getResizeEventCursorPosition($direction, event);\n        dragState.set({\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: $layout,\n        });\n    }\n    function stopDragging() {\n        resetGlobalCursorStyle();\n        dragState.set(null);\n    }\n    function unregisterPane(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const index = findPaneDataIndex($paneDataArray, paneData);\n        if (index < 0)\n            return;\n        paneDataArray.update((curr) => {\n            curr.splice(index, 1);\n            paneIdToLastNotifiedSizeMap.update((curr) => {\n                delete curr[paneData.id];\n                return curr;\n            });\n            paneDataArrayChanged.set(true);\n            return curr;\n        });\n    }\n    function isPaneCollapsed(paneData) {\n        const $paneDataArray = get(paneDataArray);\n        const $layout = get(layout);\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper($paneDataArray, paneData, $layout);\n        return collapsible === true && paneSize === collapsedSize;\n    }\n    function expandPane(paneData) {\n        const $prevLayout = get(layout);\n        const $paneDataArray = get(paneDataArray);\n        if (!paneData.constraints.collapsible)\n            return;\n        const paneConstraintsArray = $paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, minSize = 0, pivotIndices, } = paneDataHelper($paneDataArray, paneData, $prevLayout);\n        if (paneSize !== collapsedSize)\n            return;\n        // Restore this pane to the size it was before it was collapsed, if possible.\n        const prevPaneSize = get(paneSizeBeforeCollapseMap).get(paneData.id);\n        const baseSize = prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;\n        const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: $prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual($prevLayout, nextLayout))\n            return;\n        layout.set(nextLayout);\n        const $onLayout = get(onLayout);\n        $onLayout?.(nextLayout);\n        callPaneCallbacks($paneDataArray, nextLayout, get(paneIdToLastNotifiedSizeMap));\n    }\n    const paneGroupStyle = derived([direction], ([$direction]) => {\n        return styleToString({\n            display: \"flex\",\n            \"flex-direction\": $direction === \"horizontal\" ? \"row\" : \"column\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            width: \"100%\",\n        });\n    });\n    const paneGroupSelectors = derived([direction, groupId], ([$direction, $groupId]) => {\n        return {\n            \"data-pane-group\": \"\",\n            \"data-direction\": $direction,\n            \"data-pane-group-id\": $groupId,\n        };\n    });\n    const paneGroupAttrs = derived([paneGroupStyle, paneGroupSelectors], ([$style, $selectors]) => {\n        return {\n            style: $style,\n            ...$selectors,\n        };\n    });\n    function setResizeHandlerEventListeners() {\n        const $groupId = get(groupId);\n        const handles = getResizeHandleElementsForGroup($groupId);\n        const unsubHandlers = handles.map((handle) => {\n            const handleId = handle.getAttribute(\"data-pane-resizer-id\");\n            if (!handleId)\n                return noop;\n            const [idBefore, idAfter] = getResizeHandlePaneIds($groupId, handleId, get(paneDataArray));\n            if (idBefore == null || idAfter == null)\n                return noop;\n            const onKeydown = (e) => {\n                if (e.defaultPrevented || e.key !== \"Enter\")\n                    return;\n                e.preventDefault();\n                const $paneDataArray = get(paneDataArray);\n                const index = $paneDataArray.findIndex((paneData) => paneData.id === idBefore);\n                if (index < 0)\n                    return;\n                const paneData = $paneDataArray[index];\n                assert(paneData);\n                const $layout = get(layout);\n                const size = $layout[index];\n                const { collapsedSize = 0, collapsible, minSize = 0 } = paneData.constraints;\n                if (!(size != null && collapsible))\n                    return;\n                const nextLayout = adjustLayoutByDelta({\n                    delta: areNumbersAlmostEqual(size, collapsedSize) ? minSize - size : collapsedSize - size,\n                    layout: $layout,\n                    paneConstraints: $paneDataArray.map((paneData) => paneData.constraints),\n                    pivotIndices: getPivotIndices($groupId, handleId),\n                    trigger: \"keyboard\",\n                });\n                if ($layout !== nextLayout) {\n                    layout.set(nextLayout);\n                }\n            };\n            const unsubListener = addEventListener(handle, \"keydown\", onKeydown);\n            return () => {\n                unsubListener();\n            };\n        });\n        return () => {\n            unsubHandlers.forEach((unsub) => unsub());\n        };\n    }\n    function setLayout(newLayout) {\n        layout.set(newLayout);\n    }\n    function getLayout() {\n        return get(layout);\n    }\n    return {\n        methods: {\n            collapsePane,\n            expandPane,\n            getSize: getPaneSize,\n            getPaneStyle,\n            isCollapsed: isPaneCollapsed,\n            isExpanded: isPaneExpanded,\n            registerPane,\n            registerResizeHandle,\n            resizePane,\n            startDragging,\n            stopDragging,\n            unregisterPane,\n            setLayout,\n            getLayout,\n        },\n        states: {\n            direction,\n            dragState,\n            groupId,\n            paneGroupAttrs,\n            paneGroupSelectors,\n            paneGroupStyle,\n            layout,\n        },\n        options,\n    };\n}\nfunction updateResizeHandleAriaValues({ groupId, layout, paneDataArray, }) {\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId);\n    for (let index = 0; index < paneDataArray.length - 1; index++) {\n        const { valueMax, valueMin, valueNow } = calculateAriaValues({\n            layout,\n            panesArray: paneDataArray,\n            pivotIndices: [index, index + 1],\n        });\n        const resizeHandleEl = resizeHandleElements[index];\n        if (isHTMLElement(resizeHandleEl)) {\n            const paneData = paneDataArray[index];\n            resizeHandleEl.setAttribute(\"aria-controls\", paneData.id);\n            resizeHandleEl.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n            resizeHandleEl.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n            resizeHandleEl.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n        }\n    }\n    return () => {\n        resizeHandleElements.forEach((resizeHandleElement) => {\n            resizeHandleElement.removeAttribute(\"aria-controls\");\n            resizeHandleElement.removeAttribute(\"aria-valuemax\");\n            resizeHandleElement.removeAttribute(\"aria-valuemin\");\n            resizeHandleElement.removeAttribute(\"aria-valuenow\");\n        });\n    };\n}\nexport function getResizeHandleElementsForGroup(groupId) {\n    if (!isBrowser)\n        return [];\n    return Array.from(document.querySelectorAll(`[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`));\n}\nfunction getPaneGroupElement(id) {\n    if (!isBrowser)\n        return null;\n    const element = document.querySelector(`[data-pane-group][data-pane-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction noop() {\n    // do nothing\n}\nexport function getResizeHandlePaneIds(groupId, handleId, panesArray) {\n    const handle = getResizeHandleElement(handleId);\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = panesArray[index]?.id ?? null;\n    const idAfter = panesArray[index + 1]?.id ?? null;\n    return [idBefore, idAfter];\n}\nexport function getResizeHandleElement(id) {\n    if (!isBrowser)\n        return null;\n    const element = document.querySelector(`[data-pane-resizer-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nexport function getResizeHandleElementIndex(groupId, id) {\n    if (!isBrowser)\n        return null;\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handles.findIndex((handle) => handle.getAttribute(\"data-pane-resizer-id\") === id);\n    return index ?? null;\n}\nfunction getPivotIndices(groupId, dragHandleId) {\n    const index = getResizeHandleElementIndex(groupId, dragHandleId);\n    return index != null ? [index, index + 1] : [-1, -1];\n}\nfunction paneDataHelper(paneDataArray, paneData, layout) {\n    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n    const paneIndex = findPaneDataIndex(paneDataArray, paneData);\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    const isLastPane = paneIndex === paneDataArray.length - 1;\n    const pivotIndices = isLastPane ? [paneIndex - 1, paneIndex] : [paneIndex, paneIndex + 1];\n    const paneSize = layout[paneIndex];\n    return {\n        ...paneConstraints,\n        paneSize,\n        pivotIndices,\n    };\n}\nfunction findPaneDataIndex(paneDataArray, paneData) {\n    return paneDataArray.findIndex((prevPaneData) => prevPaneData.id === paneData.id);\n}\n// Layout should be pre-converted into percentages\nfunction callPaneCallbacks(paneArray, layout, paneIdToLastNotifiedSizeMap) {\n    layout.forEach((size, index) => {\n        const paneData = paneArray[index];\n        assert(paneData);\n        const { callbacks, constraints, id: paneId } = paneData;\n        const { collapsedSize = 0, collapsible } = constraints;\n        const lastNotifiedSize = paneIdToLastNotifiedSizeMap[paneId];\n        // invert the logic from below\n        if (!(lastNotifiedSize == null || size !== lastNotifiedSize))\n            return;\n        paneIdToLastNotifiedSizeMap[paneId] = size;\n        const { onCollapse, onExpand, onResize } = callbacks;\n        onResize?.(size, lastNotifiedSize);\n        if (collapsible && (onCollapse || onExpand)) {\n            if (onExpand &&\n                (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) &&\n                size !== collapsedSize) {\n                onExpand();\n            }\n            if (onCollapse &&\n                (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) &&\n                size === collapsedSize) {\n                onCollapse();\n            }\n        }\n    });\n}\nfunction getUnsafeDefaultLayout({ paneDataArray }) {\n    const layout = Array(paneDataArray.length);\n    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n    let numPanesWithSizes = 0;\n    let remainingSize = 100;\n    // Distribute default sizes first\n    for (let index = 0; index < paneDataArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            numPanesWithSizes++;\n            layout[index] = defaultSize;\n            remainingSize -= defaultSize;\n        }\n    }\n    // Remaining size should be distributed evenly between panes without default sizes\n    for (let index = 0; index < paneDataArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            continue;\n        }\n        const numRemainingPanes = paneDataArray.length - numPanesWithSizes;\n        const size = remainingSize / numRemainingPanes;\n        numPanesWithSizes++;\n        layout[index] = size;\n        remainingSize -= size;\n    }\n    return layout;\n}\n// All units must be in percentages\nfunction validatePaneGroupLayout({ layout: prevLayout, paneConstraints, }) {\n    const nextLayout = [...prevLayout];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== paneConstraints.length) {\n        throw Error(`Invalid ${paneConstraints.length} pane layout: ${nextLayout\n            .map((size) => `${size}%`)\n            .join(\", \")}`);\n    }\n    else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null);\n            const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each pane's constraints\n    for (let index = 0; index < paneConstraints.length; index++) {\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null);\n        const safeSize = resizePane({\n            paneConstraints,\n            paneIndex: index,\n            initialSize: unsafeSize,\n        });\n        if (unsafeSize != safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any pane(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!areNumbersAlmostEqual(remainingSize, 0)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const prevSize = nextLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePane({\n                paneConstraints,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (areNumbersAlmostEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getDeltaPercentage(e, dragHandleId, dir, initialDragState, keyboardResizeBy) {\n    if (isKeyDown(e)) {\n        const isHorizontal = dir === \"horizontal\";\n        let delta = 0;\n        if (e.shiftKey) {\n            delta = 100;\n        }\n        else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        }\n        else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch (e.key) {\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    }\n    else {\n        if (initialDragState == null)\n            return 0;\n        return getDragOffsetPercentage(e, dragHandleId, dir, initialDragState);\n    }\n}\nfunction getDragOffsetPercentage(e, dragHandleId, dir, initialDragState) {\n    const isHorizontal = dir === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId);\n    assert(handleElement);\n    const groupId = handleElement.getAttribute(\"data-pane-group-id\");\n    assert(groupId);\n    const { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(dir, e);\n    const groupElement = getPaneGroupElement(groupId);\n    assert(groupElement);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n    return offsetPercentage;\n}\nfunction getResizeEventCursorPosition(dir, e) {\n    const isHorizontal = dir === \"horizontal\";\n    if (isMouseEvent(e)) {\n        return isHorizontal ? e.clientX : e.clientY;\n    }\n    else if (isTouchEvent(e)) {\n        const firstTouch = e.touches[0];\n        assert(firstTouch);\n        return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    }\n    else {\n        throw Error(`Unsupported event type \"${e.type}\"`);\n    }\n}\n", "import { createPaneForge } from \"../internal/paneforge.js\";\nimport { getContext, hasContext, setContext } from \"svelte\";\nimport { removeUndefined, getOptionUpdater } from \"../internal/utils/index.js\";\nconst PF_GROUP_CTX = Symbol(\"PF_GROUP_CTX\");\nexport function setCtx(props) {\n    const paneForge = createPaneForge(removeUndefined(props));\n    const updateOption = getOptionUpdater(paneForge.options);\n    const ctxValue = { ...paneForge, updateOption };\n    setContext(PF_GROUP_CTX, ctxValue);\n    return ctxValue;\n}\nexport function getCtx(componentName) {\n    if (!hasContext(PF_GROUP_CTX)) {\n        throw new Error(`${componentName} components must be rendered with a <PaneGroup> container`);\n    }\n    return getContext(PF_GROUP_CTX);\n}\n", null, null, "import { chain } from \"../internal/utils/chain.js\";\nimport { addEventListener } from \"../internal/utils/event.js\";\n/**\n * A Svelte action that adds resize handle functionality to an element.\n * This action is used to handle the dragging of a resize handle.\n */\nexport function resizeHandleAction(node, params) {\n    let unsub = () => { };\n    function update(params) {\n        unsub();\n        const { disabled, resizeHandler, isDragging, stopDragging, onDragging = undefined } = params;\n        if (disabled || resizeHandler === null || !isDragging)\n            return;\n        const onMove = (event) => {\n            resizeHandler(event);\n        };\n        const onMouseLeave = (event) => {\n            resizeHandler(event);\n        };\n        const stopDraggingAndBlur = () => {\n            node.blur();\n            stopDragging();\n            if (onDragging) {\n                onDragging(false);\n            }\n        };\n        unsub = chain(addEventListener(document.body, \"contextmenu\", stopDraggingAndBlur), addEventListener(document.body, \"mousemove\", onMove), addEventListener(document.body, \"touchmove\", onMove, { passive: false }), addEventListener(document.body, \"mouseleave\", onMouseLeave), addEventListener(window, \"mouseup\", stopDraggingAndBlur), addEventListener(window, \"touchend\", stopDraggingAndBlur));\n    }\n    update(params);\n    return {\n        update,\n        onDestroy() {\n            unsub();\n        },\n    };\n}\n", null],
  "mappings": "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",
  "names": ["fn", "stores", "element", "paneConstraints", "delta", "pivotIndex", "prevSize", "unsafeSize", "safeSize", "element", "paneData", "resizePane", "curr", "element", "ctx", "ctx", "resizePane", "params", "ctx", "element"]
}
