import "./chunk-SA3VOP2B.js";
import {
  derived,
  writable
} from "./chunk-FIY36R7J.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  binding_callbacks,
  children,
  claim_element,
  component_subscribe,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  get_store_value,
  hasContext,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-H5NYQPBQ.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-ZJ4C2ABA.js";

// node_modules/paneforge/dist/internal/utils/lifecycle.js
function safeOnDestroy(fn) {
  try {
    onDestroy(fn);
  } catch {
    return fn();
  }
}

// node_modules/paneforge/dist/internal/utils/store.js
function derivedWithUnsubscribe(stores, fn) {
  let unsubscribers = [];
  const onUnsubscribe = (cb) => {
    unsubscribers.push(cb);
  };
  const unsubscribe = () => {
    unsubscribers.forEach((fn2) => fn2());
    unsubscribers = [];
  };
  const derivedStore = derived(stores, ($storeValues) => {
    unsubscribe();
    return fn($storeValues, onUnsubscribe);
  });
  safeOnDestroy(unsubscribe);
  const subscribe = (...args) => {
    const unsub = derivedStore.subscribe(...args);
    return () => {
      unsub();
      unsubscribe();
    };
  };
  return {
    ...derivedStore,
    subscribe
  };
}
function clientEffect(stores, fn) {
  if (!isBrowser)
    return () => {
    };
  const unsub = derivedWithUnsubscribe(stores, (stores2, onUnsubscribe) => {
    return {
      stores: stores2,
      onUnsubscribe
    };
  }).subscribe(({ stores: stores2, onUnsubscribe }) => {
    const returned = fn(stores2);
    if (returned) {
      onUnsubscribe(returned);
    }
  });
  safeOnDestroy(unsub);
  return unsub;
}
function toWritableStores(properties) {
  const result = {};
  Object.keys(properties).forEach((key) => {
    const propertyKey = key;
    const value = properties[propertyKey];
    result[propertyKey] = writable(value);
  });
  return result;
}
function getOptionUpdater(options) {
  return function(key, value) {
    if (value === void 0)
      return;
    const store = options[key];
    if (store) {
      store.set(value);
    }
  };
}

// node_modules/paneforge/dist/internal/utils/style.js
function styleToString(style) {
  return Object.keys(style).reduce((str, key) => {
    if (style[key] === void 0)
      return str;
    return str + `${key}:${style[key]};`;
  }, "");
}
var currentState = null;
var element2 = null;
function getCursorStyle(state) {
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "horizontal-max":
      return "w-resize";
    case "horizontal-min":
      return "e-resize";
    case "vertical":
      return "ns-resize";
    case "vertical-max":
      return "n-resize";
    case "vertical-min":
      return "s-resize";
  }
}
function resetGlobalCursorStyle() {
  if (element2 === null)
    return;
  document.head.removeChild(element2);
  currentState = null;
  element2 = null;
}
function setGlobalCursorStyle(state) {
  if (currentState === state)
    return;
  currentState = state;
  const style = getCursorStyle(state);
  if (element2 === null) {
    element2 = document.createElement("style");
    document.head.appendChild(element2);
  }
  element2.innerHTML = `*{cursor: ${style}!important;}`;
}
function computePaneFlexBoxStyle({ defaultSize, dragState, layout, paneData, paneIndex, precision = 3 }) {
  const size = layout[paneIndex];
  let flexGrow;
  if (size == null) {
    flexGrow = defaultSize ?? "1";
  } else if (paneData.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size.toPrecision(precision);
  }
  return styleToString({
    "flex-basis": 0,
    "flex-grow": flexGrow,
    "flex-shrink": 1,
    // Without this, pane sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a pane during resize
    // This avoid edge cases like nested iframes
    "pointer-events": dragState !== null ? "none" : void 0
  });
}

// node_modules/paneforge/dist/internal/utils/aria.js
function calculateAriaValues({ layout, panesArray, pivotIndices }) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  for (let i = 0; i < panesArray.length; i++) {
    const { constraints } = panesArray[i];
    const { maxSize = 100, minSize = 0 } = constraints;
    if (i === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  }
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}

// node_modules/paneforge/node_modules/nanoid/non-secure/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (size = 21) => {
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};

// node_modules/paneforge/dist/internal/utils/id.js
function generateId(idFromProps = null) {
  if (idFromProps == null)
    return nanoid(10);
  return idFromProps;
}

// node_modules/paneforge/dist/internal/constants.js
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var PRECISION = 10;

// node_modules/paneforge/dist/internal/utils/storage.js
function initializeStorage(storageObject) {
  try {
    if (typeof localStorage === "undefined") {
      throw new Error("localStorage is not supported in this environment");
    }
    storageObject.getItem = (name) => localStorage.getItem(name);
    storageObject.setItem = (name, value) => localStorage.setItem(name, value);
  } catch (err) {
    console.error(err);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPaneGroupKey(autoSaveId) {
  return `paneforge:${autoSaveId}`;
}
function getPaneKey(panes) {
  const sortedPaneIds = panes.map((pane) => {
    const { constraints, id, idIsFromProps, order } = pane;
    return idIsFromProps ? id : order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
  }).sort().join(",");
  return sortedPaneIds;
}
function loadSerializedPaneGroupState(autoSaveId, storage) {
  try {
    const paneGroupKey = getPaneGroupKey(autoSaveId);
    const serialized = storage.getItem(paneGroupKey);
    const parsed = JSON.parse(serialized || "");
    if (typeof parsed === "object" && parsed !== null) {
      return parsed;
    }
  } catch {
  }
  return null;
}
function loadPaneGroupState(autoSaveId, panes, storage) {
  const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};
  const paneKey = getPaneKey(panes);
  return state[paneKey] || null;
}
function savePaneGroupState(autoSaveId, panes, paneSizesBeforeCollapse, sizes, storage) {
  const paneGroupKey = getPaneGroupKey(autoSaveId);
  const paneKey = getPaneKey(panes);
  const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};
  state[paneKey] = {
    expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(paneGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}
var debounceMap = {};
function debounce(callback, durationMs = 10) {
  let timeoutId = null;
  const callable = (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}
function updateStorageValues({ autoSaveId, layout, storage, paneDataArrayStore, paneSizeBeforeCollapseStore }) {
  const $paneDataArray = get_store_value(paneDataArrayStore);
  if (layout.length === 0 || layout.length !== $paneDataArray.length)
    return;
  let debouncedSave = debounceMap[autoSaveId];
  if (debouncedSave == null) {
    debouncedSave = debounce(savePaneGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
    debounceMap[autoSaveId] = debouncedSave;
  }
  const clonedPaneDataArray = [...$paneDataArray];
  const $paneSizeBeforeCollapse = get_store_value(paneSizeBeforeCollapseStore);
  const clonedPaneSizesBeforeCollapse = new Map($paneSizeBeforeCollapse);
  debouncedSave(autoSaveId, clonedPaneDataArray, clonedPaneSizesBeforeCollapse, layout, storage);
}

// node_modules/paneforge/dist/internal/utils/object.js
function removeUndefined(obj) {
  const result = {};
  for (const key in obj) {
    const value = obj[key];
    if (value !== void 0) {
      result[key] = value;
    }
  }
  return result;
}

// node_modules/paneforge/dist/internal/utils/chain.js
function chain(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/paneforge/dist/internal/utils/event.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}

// node_modules/paneforge/dist/internal/utils/compare.js
function areNumbersAlmostEqual(actual, expected, fractionDigits = PRECISION) {
  return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;
}
function compareNumbersWithTolerance(actual, expected, fractionDigits = PRECISION) {
  const roundedActual = roundTo(actual, fractionDigits);
  const roundedExpected = roundTo(expected, fractionDigits);
  return Math.sign(roundedActual - roundedExpected);
}
function areArraysEqual(arrA, arrB) {
  if (arrA.length !== arrB.length)
    return false;
  for (let index = 0; index < arrA.length; index++) {
    if (arrA[index] !== arrB[index])
      return false;
  }
  return true;
}
function roundTo(value, decimals) {
  return parseFloat(value.toFixed(decimals));
}

// node_modules/paneforge/dist/internal/utils/assert.js
function assert(expectedCondition, message = "Assertion failed!") {
  if (!expectedCondition) {
    console.error(message);
    throw Error(message);
  }
}

// node_modules/paneforge/dist/internal/utils/resize.js
function resizePane({ paneConstraints: paneConstraintsArray, paneIndex, initialSize }) {
  const paneConstraints = paneConstraintsArray[paneIndex];
  assert(paneConstraints != null, "Pane constraints should not be null.");
  const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = paneConstraints;
  let newSize = initialSize;
  if (compareNumbersWithTolerance(newSize, minSize) < 0) {
    newSize = getAdjustedSizeForCollapsible(newSize, collapsible, collapsedSize, minSize);
  }
  newSize = Math.min(maxSize, newSize);
  return parseFloat(newSize.toFixed(PRECISION));
}
function getAdjustedSizeForCollapsible(size, collapsible, collapsedSize, minSize) {
  if (!collapsible)
    return minSize;
  const halfwayPoint = (collapsedSize + minSize) / 2;
  return compareNumbersWithTolerance(size, halfwayPoint) < 0 ? collapsedSize : minSize;
}

// node_modules/paneforge/dist/internal/utils/adjust-layout.js
function adjustLayoutByDelta({ delta, layout: prevLayout, paneConstraints: paneConstraintsArray, pivotIndices, trigger }) {
  if (areNumbersAlmostEqual(delta, 0))
    return prevLayout;
  const nextLayout = [...prevLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const paneConstraints = paneConstraintsArray[index];
        assert(paneConstraints);
        if (paneConstraints.collapsible) {
          const prevSize = prevLayout[index];
          assert(prevSize != null);
          const paneConstraints2 = paneConstraintsArray[index];
          assert(paneConstraints2);
          const { collapsedSize = 0, minSize = 0 } = paneConstraints2;
          if (areNumbersAlmostEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const paneConstraints = paneConstraintsArray[index];
        assert(paneConstraints);
        const { collapsible } = paneConstraints;
        if (collapsible) {
          const prevSize = prevLayout[index];
          assert(prevSize != null);
          const paneConstraints2 = paneConstraintsArray[index];
          assert(paneConstraints2);
          const { collapsedSize = 0, minSize = 0 } = paneConstraints2;
          if (areNumbersAlmostEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const maxSafeSize = resizePane({
        paneConstraints: paneConstraintsArray,
        paneIndex: index,
        initialSize: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index += increment;
      if (index < 0 || index >= paneConstraintsArray.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < paneConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePane({
        paneConstraints: paneConstraintsArray,
        paneIndex: index,
        initialSize: unsafeSize
      });
      if (!areNumbersAlmostEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index--;
      } else {
        index++;
      }
    }
  }
  if (areNumbersAlmostEqual(deltaApplied, 0)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = prevLayout[pivotIndex];
    assert(prevSize != null);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePane({
      paneConstraints: paneConstraintsArray,
      paneIndex: pivotIndex,
      initialSize: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex2;
      while (index >= 0 && index < paneConstraintsArray.length) {
        const prevSize2 = nextLayout[index];
        assert(prevSize2 != null);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePane({
          paneConstraints: paneConstraintsArray,
          paneIndex: index,
          initialSize: unsafeSize2
        });
        if (!areNumbersAlmostEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index] = safeSize2;
        }
        if (areNumbersAlmostEqual(deltaRemaining, 0))
          break;
        delta > 0 ? index-- : index++;
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size) => size + total, 0);
  if (!areNumbersAlmostEqual(totalSize, 100))
    return prevLayout;
  return nextLayout;
}

// node_modules/paneforge/dist/internal/utils/is.js
var isBrowser = typeof document !== "undefined";
function isHTMLElement(element3) {
  return element3 instanceof HTMLElement;
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}

// node_modules/paneforge/dist/internal/paneforge.js
var defaultStorage = {
  getItem: (name) => {
    initializeStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var defaultProps = {
  id: null,
  onLayout: null,
  keyboardResizeBy: null,
  autoSaveId: null,
  direction: "horizontal",
  storage: defaultStorage
};
function createPaneForge(props) {
  const withDefaults = {
    ...defaultProps,
    ...removeUndefined(props)
  };
  const options = toWritableStores(withDefaults);
  const { autoSaveId, direction, keyboardResizeBy, storage, onLayout } = options;
  const groupId = writable(generateId());
  const dragState = writable(null);
  const layout = writable([]);
  const paneDataArray = writable([]);
  const paneDataArrayChanged = writable(false);
  const paneIdToLastNotifiedSizeMap = writable({});
  const paneSizeBeforeCollapseMap = writable(/* @__PURE__ */ new Map());
  const prevDelta = writable(0);
  clientEffect([groupId, layout, paneDataArray], ([$groupId, $layout, $paneDataArray]) => {
    const unsub = updateResizeHandleAriaValues({
      groupId: $groupId,
      layout: $layout,
      paneDataArray: $paneDataArray
    });
    return unsub;
  });
  onMount(() => {
    const unsub = setResizeHandlerEventListeners();
    return unsub;
  });
  clientEffect([autoSaveId, layout, storage], ([$autoSaveId, $layout, $storage]) => {
    if (!$autoSaveId)
      return;
    updateStorageValues({
      autoSaveId: $autoSaveId,
      layout: $layout,
      storage: $storage,
      paneDataArrayStore: paneDataArray,
      paneSizeBeforeCollapseStore: paneSizeBeforeCollapseMap
    });
  });
  function collapsePane(paneData) {
    const $prevLayout = get_store_value(layout);
    const $paneDataArray = get_store_value(paneDataArray);
    if (!paneData.constraints.collapsible)
      return;
    const paneConstraintsArray = $paneDataArray.map((paneData2) => paneData2.constraints);
    const { collapsedSize = 0, paneSize, pivotIndices } = paneDataHelper($paneDataArray, paneData, $prevLayout);
    assert(paneSize != null);
    if (paneSize === collapsedSize)
      return;
    paneSizeBeforeCollapseMap.update((curr) => {
      curr.set(paneData.id, paneSize);
      return curr;
    });
    const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;
    const delta = isLastPane ? paneSize - collapsedSize : collapsedSize - paneSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      layout: $prevLayout,
      paneConstraints: paneConstraintsArray,
      pivotIndices,
      trigger: "imperative-api"
    });
    if (areArraysEqual($prevLayout, nextLayout))
      return;
    layout.set(nextLayout);
    const $onLayout = get_store_value(onLayout);
    if ($onLayout) {
      $onLayout(nextLayout);
    }
    callPaneCallbacks($paneDataArray, nextLayout, get_store_value(paneIdToLastNotifiedSizeMap));
  }
  function getPaneSize(paneData) {
    const $layout = get_store_value(layout);
    const $paneDataArray = get_store_value(paneDataArray);
    const { paneSize } = paneDataHelper($paneDataArray, paneData, $layout);
    return paneSize;
  }
  const getPaneStyle = derived([paneDataArray, layout, dragState], ([$paneDataArray, $layout, $dragState]) => {
    return (paneData, defaultSize) => {
      const paneIndex = findPaneDataIndex($paneDataArray, paneData);
      return computePaneFlexBoxStyle({
        defaultSize,
        dragState: $dragState,
        layout: $layout,
        paneData: $paneDataArray,
        paneIndex
      });
    };
  });
  function isPaneExpanded(paneData) {
    const $paneDataArray = get_store_value(paneDataArray);
    const $layout = get_store_value(layout);
    const { collapsedSize = 0, collapsible, paneSize } = paneDataHelper($paneDataArray, paneData, $layout);
    return !collapsible || paneSize > collapsedSize;
  }
  function registerPane(paneData) {
    paneDataArray.update((curr) => {
      const newArr = [...curr, paneData];
      newArr.sort((paneA, paneB) => {
        const orderA = paneA.order;
        const orderB = paneB.order;
        if (orderA == null && orderB == null) {
          return 0;
        } else if (orderA == null) {
          return -1;
        } else if (orderB == null) {
          return 1;
        } else {
          return orderA - orderB;
        }
      });
      return newArr;
    });
    paneDataArrayChanged.set(true);
  }
  clientEffect([paneDataArrayChanged], ([$paneDataArrayChanged]) => {
    if (!$paneDataArrayChanged)
      return;
    paneDataArrayChanged.set(false);
    const $autoSaveId = get_store_value(autoSaveId);
    const $storage = get_store_value(storage);
    const $prevLayout = get_store_value(layout);
    const $paneDataArray = get_store_value(paneDataArray);
    let unsafeLayout = null;
    if ($autoSaveId) {
      const state = loadPaneGroupState($autoSaveId, $paneDataArray, $storage);
      if (state) {
        paneSizeBeforeCollapseMap.set(new Map(Object.entries(state.expandToSizes)));
        unsafeLayout = state.layout;
      }
    }
    if (unsafeLayout == null) {
      unsafeLayout = getUnsafeDefaultLayout({
        paneDataArray: $paneDataArray
      });
    }
    const nextLayout = validatePaneGroupLayout({
      layout: unsafeLayout,
      paneConstraints: $paneDataArray.map((paneData) => paneData.constraints)
    });
    if (areArraysEqual($prevLayout, nextLayout))
      return;
    layout.set(nextLayout);
    const $onLayout = get_store_value(onLayout);
    if ($onLayout) {
      $onLayout(nextLayout);
    }
    callPaneCallbacks($paneDataArray, nextLayout, get_store_value(paneIdToLastNotifiedSizeMap));
  });
  function registerResizeHandle(dragHandleId) {
    return function resizeHandler(event) {
      event.preventDefault();
      const $direction = get_store_value(direction);
      const $dragState = get_store_value(dragState);
      const $groupId = get_store_value(groupId);
      const $keyboardResizeBy = get_store_value(keyboardResizeBy);
      const $prevLayout = get_store_value(layout);
      const $paneDataArray = get_store_value(paneDataArray);
      const { initialLayout } = $dragState ?? {};
      const pivotIndices = getPivotIndices($groupId, dragHandleId);
      let delta = getDeltaPercentage(event, dragHandleId, $direction, $dragState, $keyboardResizeBy);
      if (delta === 0)
        return;
      const isHorizontal = $direction === "horizontal";
      if (document.dir === "rtl" && isHorizontal) {
        delta = -delta;
      }
      const paneConstraints = $paneDataArray.map((paneData) => paneData.constraints);
      const nextLayout = adjustLayoutByDelta({
        delta,
        layout: initialLayout ?? $prevLayout,
        paneConstraints,
        pivotIndices,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      });
      const layoutChanged = !areArraysEqual($prevLayout, nextLayout);
      if (isMouseEvent(event) || isTouchEvent(event)) {
        const $prevDelta = get_store_value(prevDelta);
        if ($prevDelta != delta) {
          prevDelta.set(delta);
          if (!layoutChanged) {
            if (isHorizontal) {
              setGlobalCursorStyle(delta < 0 ? "horizontal-min" : "horizontal-max");
            } else {
              setGlobalCursorStyle(delta < 0 ? "vertical-min" : "vertical-max");
            }
          } else {
            setGlobalCursorStyle(isHorizontal ? "horizontal" : "vertical");
          }
        }
      }
      if (layoutChanged) {
        layout.set(nextLayout);
        const $onLayout = get_store_value(onLayout);
        if ($onLayout) {
          $onLayout(nextLayout);
        }
        callPaneCallbacks($paneDataArray, nextLayout, get_store_value(paneIdToLastNotifiedSizeMap));
      }
    };
  }
  function resizePane2(paneData, unsafePaneSize) {
    const $prevLayout = get_store_value(layout);
    const $paneDataArray = get_store_value(paneDataArray);
    const paneConstraintsArr = $paneDataArray.map((paneData2) => paneData2.constraints);
    const { paneSize, pivotIndices } = paneDataHelper($paneDataArray, paneData, $prevLayout);
    assert(paneSize != null);
    const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;
    const delta = isLastPane ? paneSize - unsafePaneSize : unsafePaneSize - paneSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      layout: $prevLayout,
      paneConstraints: paneConstraintsArr,
      pivotIndices,
      trigger: "imperative-api"
    });
    if (areArraysEqual($prevLayout, nextLayout))
      return;
    layout.set(nextLayout);
    const $onLayout = get_store_value(onLayout);
    $onLayout?.(nextLayout);
    callPaneCallbacks($paneDataArray, nextLayout, get_store_value(paneIdToLastNotifiedSizeMap));
  }
  function startDragging(dragHandleId, event) {
    const $direction = get_store_value(direction);
    const $layout = get_store_value(layout);
    const handleElement = getResizeHandleElement(dragHandleId);
    assert(handleElement);
    const initialCursorPosition = getResizeEventCursorPosition($direction, event);
    dragState.set({
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: $layout
    });
  }
  function stopDragging() {
    resetGlobalCursorStyle();
    dragState.set(null);
  }
  function unregisterPane(paneData) {
    const $paneDataArray = get_store_value(paneDataArray);
    const index = findPaneDataIndex($paneDataArray, paneData);
    if (index < 0)
      return;
    paneDataArray.update((curr) => {
      curr.splice(index, 1);
      paneIdToLastNotifiedSizeMap.update((curr2) => {
        delete curr2[paneData.id];
        return curr2;
      });
      paneDataArrayChanged.set(true);
      return curr;
    });
  }
  function isPaneCollapsed(paneData) {
    const $paneDataArray = get_store_value(paneDataArray);
    const $layout = get_store_value(layout);
    const { collapsedSize = 0, collapsible, paneSize } = paneDataHelper($paneDataArray, paneData, $layout);
    return collapsible === true && paneSize === collapsedSize;
  }
  function expandPane(paneData) {
    const $prevLayout = get_store_value(layout);
    const $paneDataArray = get_store_value(paneDataArray);
    if (!paneData.constraints.collapsible)
      return;
    const paneConstraintsArray = $paneDataArray.map((paneData2) => paneData2.constraints);
    const { collapsedSize = 0, paneSize, minSize = 0, pivotIndices } = paneDataHelper($paneDataArray, paneData, $prevLayout);
    if (paneSize !== collapsedSize)
      return;
    const prevPaneSize = get_store_value(paneSizeBeforeCollapseMap).get(paneData.id);
    const baseSize = prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;
    const isLastPane = findPaneDataIndex($paneDataArray, paneData) === $paneDataArray.length - 1;
    const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      layout: $prevLayout,
      paneConstraints: paneConstraintsArray,
      pivotIndices,
      trigger: "imperative-api"
    });
    if (areArraysEqual($prevLayout, nextLayout))
      return;
    layout.set(nextLayout);
    const $onLayout = get_store_value(onLayout);
    $onLayout?.(nextLayout);
    callPaneCallbacks($paneDataArray, nextLayout, get_store_value(paneIdToLastNotifiedSizeMap));
  }
  const paneGroupStyle = derived([direction], ([$direction]) => {
    return styleToString({
      display: "flex",
      "flex-direction": $direction === "horizontal" ? "row" : "column",
      height: "100%",
      overflow: "hidden",
      width: "100%"
    });
  });
  const paneGroupSelectors = derived([direction, groupId], ([$direction, $groupId]) => {
    return {
      "data-pane-group": "",
      "data-direction": $direction,
      "data-pane-group-id": $groupId
    };
  });
  const paneGroupAttrs = derived([paneGroupStyle, paneGroupSelectors], ([$style, $selectors]) => {
    return {
      style: $style,
      ...$selectors
    };
  });
  function setResizeHandlerEventListeners() {
    const $groupId = get_store_value(groupId);
    const handles = getResizeHandleElementsForGroup($groupId);
    const unsubHandlers = handles.map((handle) => {
      const handleId = handle.getAttribute("data-pane-resizer-id");
      if (!handleId)
        return noop;
      const [idBefore, idAfter] = getResizeHandlePaneIds($groupId, handleId, get_store_value(paneDataArray));
      if (idBefore == null || idAfter == null)
        return noop;
      const onKeydown = (e) => {
        if (e.defaultPrevented || e.key !== "Enter")
          return;
        e.preventDefault();
        const $paneDataArray = get_store_value(paneDataArray);
        const index = $paneDataArray.findIndex((paneData2) => paneData2.id === idBefore);
        if (index < 0)
          return;
        const paneData = $paneDataArray[index];
        assert(paneData);
        const $layout = get_store_value(layout);
        const size = $layout[index];
        const { collapsedSize = 0, collapsible, minSize = 0 } = paneData.constraints;
        if (!(size != null && collapsible))
          return;
        const nextLayout = adjustLayoutByDelta({
          delta: areNumbersAlmostEqual(size, collapsedSize) ? minSize - size : collapsedSize - size,
          layout: $layout,
          paneConstraints: $paneDataArray.map((paneData2) => paneData2.constraints),
          pivotIndices: getPivotIndices($groupId, handleId),
          trigger: "keyboard"
        });
        if ($layout !== nextLayout) {
          layout.set(nextLayout);
        }
      };
      const unsubListener = addEventListener(handle, "keydown", onKeydown);
      return () => {
        unsubListener();
      };
    });
    return () => {
      unsubHandlers.forEach((unsub) => unsub());
    };
  }
  function setLayout(newLayout) {
    layout.set(newLayout);
  }
  function getLayout() {
    return get_store_value(layout);
  }
  return {
    methods: {
      collapsePane,
      expandPane,
      getSize: getPaneSize,
      getPaneStyle,
      isCollapsed: isPaneCollapsed,
      isExpanded: isPaneExpanded,
      registerPane,
      registerResizeHandle,
      resizePane: resizePane2,
      startDragging,
      stopDragging,
      unregisterPane,
      setLayout,
      getLayout
    },
    states: {
      direction,
      dragState,
      groupId,
      paneGroupAttrs,
      paneGroupSelectors,
      paneGroupStyle,
      layout
    },
    options
  };
}
function updateResizeHandleAriaValues({ groupId, layout, paneDataArray }) {
  const resizeHandleElements = getResizeHandleElementsForGroup(groupId);
  for (let index = 0; index < paneDataArray.length - 1; index++) {
    const { valueMax, valueMin, valueNow } = calculateAriaValues({
      layout,
      panesArray: paneDataArray,
      pivotIndices: [index, index + 1]
    });
    const resizeHandleEl = resizeHandleElements[index];
    if (isHTMLElement(resizeHandleEl)) {
      const paneData = paneDataArray[index];
      resizeHandleEl.setAttribute("aria-controls", paneData.id);
      resizeHandleEl.setAttribute("aria-valuemax", "" + Math.round(valueMax));
      resizeHandleEl.setAttribute("aria-valuemin", "" + Math.round(valueMin));
      resizeHandleEl.setAttribute("aria-valuenow", valueNow != null ? "" + Math.round(valueNow) : "");
    }
  }
  return () => {
    resizeHandleElements.forEach((resizeHandleElement) => {
      resizeHandleElement.removeAttribute("aria-controls");
      resizeHandleElement.removeAttribute("aria-valuemax");
      resizeHandleElement.removeAttribute("aria-valuemin");
      resizeHandleElement.removeAttribute("aria-valuenow");
    });
  };
}
function getResizeHandleElementsForGroup(groupId) {
  if (!isBrowser)
    return [];
  return Array.from(document.querySelectorAll(`[data-pane-resizer-id][data-pane-group-id="${groupId}"]`));
}
function getPaneGroupElement(id) {
  if (!isBrowser)
    return null;
  const element3 = document.querySelector(`[data-pane-group][data-pane-group-id="${id}"]`);
  if (element3) {
    return element3;
  }
  return null;
}
function noop() {
}
function getResizeHandlePaneIds(groupId, handleId, panesArray) {
  const handle = getResizeHandleElement(handleId);
  const handles = getResizeHandleElementsForGroup(groupId);
  const index = handle ? handles.indexOf(handle) : -1;
  const idBefore = panesArray[index]?.id ?? null;
  const idAfter = panesArray[index + 1]?.id ?? null;
  return [idBefore, idAfter];
}
function getResizeHandleElement(id) {
  if (!isBrowser)
    return null;
  const element3 = document.querySelector(`[data-pane-resizer-id="${id}"]`);
  if (element3) {
    return element3;
  }
  return null;
}
function getResizeHandleElementIndex(groupId, id) {
  if (!isBrowser)
    return null;
  const handles = getResizeHandleElementsForGroup(groupId);
  const index = handles.findIndex((handle) => handle.getAttribute("data-pane-resizer-id") === id);
  return index ?? null;
}
function getPivotIndices(groupId, dragHandleId) {
  const index = getResizeHandleElementIndex(groupId, dragHandleId);
  return index != null ? [index, index + 1] : [-1, -1];
}
function paneDataHelper(paneDataArray, paneData, layout) {
  const paneConstraintsArray = paneDataArray.map((paneData2) => paneData2.constraints);
  const paneIndex = findPaneDataIndex(paneDataArray, paneData);
  const paneConstraints = paneConstraintsArray[paneIndex];
  const isLastPane = paneIndex === paneDataArray.length - 1;
  const pivotIndices = isLastPane ? [paneIndex - 1, paneIndex] : [paneIndex, paneIndex + 1];
  const paneSize = layout[paneIndex];
  return {
    ...paneConstraints,
    paneSize,
    pivotIndices
  };
}
function findPaneDataIndex(paneDataArray, paneData) {
  return paneDataArray.findIndex((prevPaneData) => prevPaneData.id === paneData.id);
}
function callPaneCallbacks(paneArray, layout, paneIdToLastNotifiedSizeMap) {
  layout.forEach((size, index) => {
    const paneData = paneArray[index];
    assert(paneData);
    const { callbacks, constraints, id: paneId } = paneData;
    const { collapsedSize = 0, collapsible } = constraints;
    const lastNotifiedSize = paneIdToLastNotifiedSizeMap[paneId];
    if (!(lastNotifiedSize == null || size !== lastNotifiedSize))
      return;
    paneIdToLastNotifiedSizeMap[paneId] = size;
    const { onCollapse, onExpand, onResize } = callbacks;
    onResize?.(size, lastNotifiedSize);
    if (collapsible && (onCollapse || onExpand)) {
      if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {
        onExpand();
      }
      if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size === collapsedSize) {
        onCollapse();
      }
    }
  });
}
function getUnsafeDefaultLayout({ paneDataArray }) {
  const layout = Array(paneDataArray.length);
  const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);
  let numPanesWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < paneDataArray.length; index++) {
    const paneConstraints = paneConstraintsArray[index];
    assert(paneConstraints);
    const { defaultSize } = paneConstraints;
    if (defaultSize != null) {
      numPanesWithSizes++;
      layout[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < paneDataArray.length; index++) {
    const paneConstraints = paneConstraintsArray[index];
    assert(paneConstraints);
    const { defaultSize } = paneConstraints;
    if (defaultSize != null) {
      continue;
    }
    const numRemainingPanes = paneDataArray.length - numPanesWithSizes;
    const size = remainingSize / numRemainingPanes;
    numPanesWithSizes++;
    layout[index] = size;
    remainingSize -= size;
  }
  return layout;
}
function validatePaneGroupLayout({ layout: prevLayout, paneConstraints }) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== paneConstraints.length) {
    throw Error(`Invalid ${paneConstraints.length} pane layout: ${nextLayout.map((size) => `${size}%`).join(", ")}`);
  } else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {
    for (let index = 0; index < paneConstraints.length; index++) {
      const unsafeSize = nextLayout[index];
      assert(unsafeSize != null);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < paneConstraints.length; index++) {
    const unsafeSize = nextLayout[index];
    assert(unsafeSize != null);
    const safeSize = resizePane({
      paneConstraints,
      paneIndex: index,
      initialSize: unsafeSize
    });
    if (unsafeSize != safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index] = safeSize;
    }
  }
  if (!areNumbersAlmostEqual(remainingSize, 0)) {
    for (let index = 0; index < paneConstraints.length; index++) {
      const prevSize = nextLayout[index];
      assert(prevSize != null);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePane({
        paneConstraints,
        paneIndex: index,
        initialSize: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index] = safeSize;
        if (areNumbersAlmostEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextLayout;
}
function getDeltaPercentage(e, dragHandleId, dir, initialDragState, keyboardResizeBy) {
  if (isKeyDown(e)) {
    const isHorizontal = dir === "horizontal";
    let delta = 0;
    if (e.shiftKey) {
      delta = 100;
    } else if (keyboardResizeBy != null) {
      delta = keyboardResizeBy;
    } else {
      delta = 10;
    }
    let movement = 0;
    switch (e.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null)
      return 0;
    return getDragOffsetPercentage(e, dragHandleId, dir, initialDragState);
  }
}
function getDragOffsetPercentage(e, dragHandleId, dir, initialDragState) {
  const isHorizontal = dir === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId);
  assert(handleElement);
  const groupId = handleElement.getAttribute("data-pane-group-id");
  assert(groupId);
  const { initialCursorPosition } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(dir, e);
  const groupElement = getPaneGroupElement(groupId);
  assert(groupElement);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function getResizeEventCursorPosition(dir, e) {
  const isHorizontal = dir === "horizontal";
  if (isMouseEvent(e)) {
    return isHorizontal ? e.clientX : e.clientY;
  } else if (isTouchEvent(e)) {
    const firstTouch = e.touches[0];
    assert(firstTouch);
    return isHorizontal ? firstTouch.screenX : firstTouch.screenY;
  } else {
    throw Error(`Unsupported event type "${e.type}"`);
  }
}

// node_modules/paneforge/dist/components/ctx.js
var PF_GROUP_CTX = Symbol("PF_GROUP_CTX");
function setCtx(props) {
  const paneForge = createPaneForge(removeUndefined(props));
  const updateOption = getOptionUpdater(paneForge.options);
  const ctxValue = { ...paneForge, updateOption };
  setContext(PF_GROUP_CTX, ctxValue);
  return ctxValue;
}
function getCtx(componentName) {
  if (!hasContext(PF_GROUP_CTX)) {
    throw new Error(`${componentName} components must be rendered with a <PaneGroup> container`);
  }
  return getContext(PF_GROUP_CTX);
}

// node_modules/paneforge/dist/components/pane-group.svelte
var file = "node_modules\\paneforge\\dist\\components\\pane-group.svelte";
function create_fragment(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  let div_levels = [
    { id: (
      /*$groupId*/
      ctx[2]
    ) },
    /*$paneGroupSelectors*/
    ctx[3],
    { style: (
      /*style*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 46, 0, 1068);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[19](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*$groupId*/
        4) && { id: (
          /*$groupId*/
          ctx2[2]
        ) },
        dirty & /*$paneGroupSelectors*/
        8 && /*$paneGroupSelectors*/
        ctx2[3],
        (!current || dirty & /*style*/
        2) && { style: (
          /*style*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let style;
  const omit_props_names = [
    "autoSaveId",
    "direction",
    "id",
    "keyboardResizeBy",
    "onLayoutChange",
    "storage",
    "el",
    "paneGroup",
    "style"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $paneGroupStyle;
  let $groupId;
  let $paneGroupSelectors;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pane_group", slots, ["default"]);
  let { autoSaveId = null } = $$props;
  let { direction } = $$props;
  let { id = null } = $$props;
  let { keyboardResizeBy = null } = $$props;
  let { onLayoutChange = null } = $$props;
  let { storage = defaultStorage } = $$props;
  let { el = void 0 } = $$props;
  let { paneGroup = void 0 } = $$props;
  let { style: styleFromProps = void 0 } = $$props;
  const { states: { paneGroupStyle, paneGroupSelectors, groupId }, methods: { setLayout, getLayout }, updateOption } = setCtx({
    autoSaveId,
    direction,
    id,
    keyboardResizeBy,
    onLayout: onLayoutChange,
    storage
  });
  validate_store(paneGroupStyle, "paneGroupStyle");
  component_subscribe($$self, paneGroupStyle, (value) => $$invalidate(16, $paneGroupStyle = value));
  validate_store(paneGroupSelectors, "paneGroupSelectors");
  component_subscribe($$self, paneGroupSelectors, (value) => $$invalidate(3, $paneGroupSelectors = value));
  validate_store(groupId, "groupId");
  component_subscribe($$self, groupId, (value) => $$invalidate(2, $groupId = value));
  paneGroup = {
    getLayout,
    setLayout,
    getId: () => $groupId
  };
  $$self.$$.on_mount.push(function() {
    if (direction === void 0 && !("direction" in $$props || $$self.$$.bound[$$self.$$.props["direction"]])) {
      console.warn("<Pane_group> was created without expected prop 'direction'");
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("autoSaveId" in $$new_props)
      $$invalidate(9, autoSaveId = $$new_props.autoSaveId);
    if ("direction" in $$new_props)
      $$invalidate(10, direction = $$new_props.direction);
    if ("id" in $$new_props)
      $$invalidate(11, id = $$new_props.id);
    if ("keyboardResizeBy" in $$new_props)
      $$invalidate(12, keyboardResizeBy = $$new_props.keyboardResizeBy);
    if ("onLayoutChange" in $$new_props)
      $$invalidate(13, onLayoutChange = $$new_props.onLayoutChange);
    if ("storage" in $$new_props)
      $$invalidate(14, storage = $$new_props.storage);
    if ("el" in $$new_props)
      $$invalidate(0, el = $$new_props.el);
    if ("paneGroup" in $$new_props)
      $$invalidate(8, paneGroup = $$new_props.paneGroup);
    if ("style" in $$new_props)
      $$invalidate(15, styleFromProps = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setCtx,
    defaultStorage,
    autoSaveId,
    direction,
    id,
    keyboardResizeBy,
    onLayoutChange,
    storage,
    el,
    paneGroup,
    styleFromProps,
    paneGroupStyle,
    paneGroupSelectors,
    groupId,
    setLayout,
    getLayout,
    updateOption,
    style,
    $paneGroupStyle,
    $groupId,
    $paneGroupSelectors
  });
  $$self.$inject_state = ($$new_props) => {
    if ("autoSaveId" in $$props)
      $$invalidate(9, autoSaveId = $$new_props.autoSaveId);
    if ("direction" in $$props)
      $$invalidate(10, direction = $$new_props.direction);
    if ("id" in $$props)
      $$invalidate(11, id = $$new_props.id);
    if ("keyboardResizeBy" in $$props)
      $$invalidate(12, keyboardResizeBy = $$new_props.keyboardResizeBy);
    if ("onLayoutChange" in $$props)
      $$invalidate(13, onLayoutChange = $$new_props.onLayoutChange);
    if ("storage" in $$props)
      $$invalidate(14, storage = $$new_props.storage);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("paneGroup" in $$props)
      $$invalidate(8, paneGroup = $$new_props.paneGroup);
    if ("styleFromProps" in $$props)
      $$invalidate(15, styleFromProps = $$new_props.styleFromProps);
    if ("style" in $$props)
      $$invalidate(1, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoSaveId*/
    512) {
      $:
        updateOption("autoSaveId", autoSaveId);
    }
    if ($$self.$$.dirty & /*direction*/
    1024) {
      $:
        updateOption("direction", direction);
    }
    if ($$self.$$.dirty & /*id*/
    2048) {
      $:
        updateOption("id", id);
    }
    if ($$self.$$.dirty & /*keyboardResizeBy*/
    4096) {
      $:
        updateOption("keyboardResizeBy", keyboardResizeBy);
    }
    if ($$self.$$.dirty & /*onLayoutChange*/
    8192) {
      $:
        updateOption("onLayout", onLayoutChange);
    }
    if ($$self.$$.dirty & /*storage*/
    16384) {
      $:
        updateOption("storage", storage);
    }
    if ($$self.$$.dirty & /*$paneGroupStyle, styleFromProps*/
    98304) {
      $:
        $$invalidate(1, style = $paneGroupStyle + (styleFromProps ?? ""));
    }
  };
  return [
    el,
    style,
    $groupId,
    $paneGroupSelectors,
    paneGroupStyle,
    paneGroupSelectors,
    groupId,
    $$restProps,
    paneGroup,
    autoSaveId,
    direction,
    id,
    keyboardResizeBy,
    onLayoutChange,
    storage,
    styleFromProps,
    $paneGroupStyle,
    $$scope,
    slots,
    div_binding
  ];
}
var Pane_group = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      autoSaveId: 9,
      direction: 10,
      id: 11,
      keyboardResizeBy: 12,
      onLayoutChange: 13,
      storage: 14,
      el: 0,
      paneGroup: 8,
      style: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pane_group",
      options,
      id: create_fragment.name
    });
  }
  get autoSaveId() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoSaveId(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyboardResizeBy() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyboardResizeBy(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onLayoutChange() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onLayoutChange(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get storage() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set storage(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paneGroup() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paneGroup(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Pane_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Pane_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var pane_group_default = Pane_group;

// node_modules/paneforge/dist/components/pane.svelte
var file2 = "node_modules\\paneforge\\dist\\components\\pane.svelte";
function create_fragment2(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let div_levels = [
    { style: (
      /*style*/
      ctx[2]
    ) },
    /*attrs*/
    ctx[1],
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 79, 0, 1719);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[23](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*style*/
        4) && { style: (
          /*style*/
          ctx2[2]
        ) },
        dirty[0] & /*attrs*/
        2 && /*attrs*/
        ctx2[1],
        dirty[0] & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[23](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let style;
  let attrs;
  const omit_props_names = [
    "collapsedSize",
    "collapsible",
    "defaultSize",
    "maxSize",
    "minSize",
    "onCollapse",
    "onExpand",
    "onResize",
    "order",
    "el",
    "pane",
    "id",
    "style"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupId;
  let $getPaneStyle;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pane", slots, ["default"]);
  let { collapsedSize = void 0 } = $$props;
  let { collapsible = void 0 } = $$props;
  let { defaultSize = void 0 } = $$props;
  let { maxSize = void 0 } = $$props;
  let { minSize = void 0 } = $$props;
  let { onCollapse = void 0 } = $$props;
  let { onExpand = void 0 } = $$props;
  let { onResize = void 0 } = $$props;
  let { order = void 0 } = $$props;
  let { el = void 0 } = $$props;
  let { pane = void 0 } = $$props;
  let { id: idFromProps = void 0 } = $$props;
  let { style: styleFromProps = void 0 } = $$props;
  const { methods: { getPaneStyle, registerPane, unregisterPane, collapsePane, expandPane, getSize, isCollapsed, isExpanded, resizePane: resizePane2 }, states: { groupId } } = getCtx("Pane");
  validate_store(getPaneStyle, "getPaneStyle");
  component_subscribe($$self, getPaneStyle, (value) => $$invalidate(20, $getPaneStyle = value));
  validate_store(groupId, "groupId");
  component_subscribe($$self, groupId, (value) => $$invalidate(19, $groupId = value));
  const paneId = generateId(idFromProps);
  let paneData;
  pane = {
    collapse: () => {
      collapsePane(paneData);
    },
    expand: () => expandPane(paneData),
    getSize: () => getSize(paneData),
    isCollapsed: () => isCollapsed(paneData),
    isExpanded: () => isExpanded(paneData),
    resize: (size) => resizePane2(paneData, size),
    getId: () => paneId
  };
  onMount(() => {
    registerPane(paneData);
    return () => {
      unregisterPane(paneData);
    };
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("collapsedSize" in $$new_props)
      $$invalidate(7, collapsedSize = $$new_props.collapsedSize);
    if ("collapsible" in $$new_props)
      $$invalidate(8, collapsible = $$new_props.collapsible);
    if ("defaultSize" in $$new_props)
      $$invalidate(9, defaultSize = $$new_props.defaultSize);
    if ("maxSize" in $$new_props)
      $$invalidate(10, maxSize = $$new_props.maxSize);
    if ("minSize" in $$new_props)
      $$invalidate(11, minSize = $$new_props.minSize);
    if ("onCollapse" in $$new_props)
      $$invalidate(12, onCollapse = $$new_props.onCollapse);
    if ("onExpand" in $$new_props)
      $$invalidate(13, onExpand = $$new_props.onExpand);
    if ("onResize" in $$new_props)
      $$invalidate(14, onResize = $$new_props.onResize);
    if ("order" in $$new_props)
      $$invalidate(15, order = $$new_props.order);
    if ("el" in $$new_props)
      $$invalidate(0, el = $$new_props.el);
    if ("pane" in $$new_props)
      $$invalidate(6, pane = $$new_props.pane);
    if ("id" in $$new_props)
      $$invalidate(16, idFromProps = $$new_props.id);
    if ("style" in $$new_props)
      $$invalidate(17, styleFromProps = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    generateId,
    onMount,
    getCtx,
    collapsedSize,
    collapsible,
    defaultSize,
    maxSize,
    minSize,
    onCollapse,
    onExpand,
    onResize,
    order,
    el,
    pane,
    idFromProps,
    styleFromProps,
    getPaneStyle,
    registerPane,
    unregisterPane,
    collapsePane,
    expandPane,
    getSize,
    isCollapsed,
    isExpanded,
    resizePane: resizePane2,
    groupId,
    paneId,
    paneData,
    attrs,
    style,
    $groupId,
    $getPaneStyle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("collapsedSize" in $$props)
      $$invalidate(7, collapsedSize = $$new_props.collapsedSize);
    if ("collapsible" in $$props)
      $$invalidate(8, collapsible = $$new_props.collapsible);
    if ("defaultSize" in $$props)
      $$invalidate(9, defaultSize = $$new_props.defaultSize);
    if ("maxSize" in $$props)
      $$invalidate(10, maxSize = $$new_props.maxSize);
    if ("minSize" in $$props)
      $$invalidate(11, minSize = $$new_props.minSize);
    if ("onCollapse" in $$props)
      $$invalidate(12, onCollapse = $$new_props.onCollapse);
    if ("onExpand" in $$props)
      $$invalidate(13, onExpand = $$new_props.onExpand);
    if ("onResize" in $$props)
      $$invalidate(14, onResize = $$new_props.onResize);
    if ("order" in $$props)
      $$invalidate(15, order = $$new_props.order);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("pane" in $$props)
      $$invalidate(6, pane = $$new_props.pane);
    if ("idFromProps" in $$props)
      $$invalidate(16, idFromProps = $$new_props.idFromProps);
    if ("styleFromProps" in $$props)
      $$invalidate(17, styleFromProps = $$new_props.styleFromProps);
    if ("paneData" in $$props)
      $$invalidate(18, paneData = $$new_props.paneData);
    if ("attrs" in $$props)
      $$invalidate(1, attrs = $$new_props.attrs);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*onCollapse, onExpand, onResize, collapsedSize, collapsible, defaultSize, maxSize, minSize, idFromProps, order*/
    130944) {
      $:
        $$invalidate(18, paneData = {
          callbacks: { onCollapse, onExpand, onResize },
          constraints: {
            collapsedSize,
            collapsible,
            defaultSize,
            maxSize,
            minSize
          },
          id: paneId,
          idIsFromProps: idFromProps !== void 0,
          order
        });
    }
    if ($$self.$$.dirty[0] & /*$getPaneStyle, paneData, defaultSize, styleFromProps*/
    1442304) {
      $:
        $$invalidate(2, style = $getPaneStyle(paneData, defaultSize) + (styleFromProps ?? ""));
    }
    if ($$self.$$.dirty[0] & /*$groupId*/
    524288) {
      $:
        $$invalidate(1, attrs = {
          "data-pane": "",
          "data-pane-id": paneId,
          "data-pane-group-id": $groupId
        });
    }
  };
  return [
    el,
    attrs,
    style,
    getPaneStyle,
    groupId,
    $$restProps,
    pane,
    collapsedSize,
    collapsible,
    defaultSize,
    maxSize,
    minSize,
    onCollapse,
    onExpand,
    onResize,
    order,
    idFromProps,
    styleFromProps,
    paneData,
    $groupId,
    $getPaneStyle,
    $$scope,
    slots,
    div_binding
  ];
}
var Pane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        collapsedSize: 7,
        collapsible: 8,
        defaultSize: 9,
        maxSize: 10,
        minSize: 11,
        onCollapse: 12,
        onExpand: 13,
        onResize: 14,
        order: 15,
        el: 0,
        pane: 6,
        id: 16,
        style: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pane",
      options,
      id: create_fragment2.name
    });
  }
  get collapsedSize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapsedSize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapsible() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapsible(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultSize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultSize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxSize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxSize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minSize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minSize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onCollapse() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onCollapse(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExpand() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExpand(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onResize() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onResize(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get order() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set order(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pane() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pane(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Pane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Pane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var pane_default = Pane;

// node_modules/paneforge/dist/components/pane-resizer.js
function resizeHandleAction(node, params) {
  let unsub = () => {
  };
  function update(params2) {
    unsub();
    const { disabled, resizeHandler, isDragging, stopDragging, onDragging = void 0 } = params2;
    if (disabled || resizeHandler === null || !isDragging)
      return;
    const onMove = (event) => {
      resizeHandler(event);
    };
    const onMouseLeave = (event) => {
      resizeHandler(event);
    };
    const stopDraggingAndBlur = () => {
      node.blur();
      stopDragging();
      if (onDragging) {
        onDragging(false);
      }
    };
    unsub = chain(addEventListener(document.body, "contextmenu", stopDraggingAndBlur), addEventListener(document.body, "mousemove", onMove), addEventListener(document.body, "touchmove", onMove, { passive: false }), addEventListener(document.body, "mouseleave", onMouseLeave), addEventListener(window, "mouseup", stopDraggingAndBlur), addEventListener(window, "touchend", stopDraggingAndBlur));
  }
  update(params);
  return {
    update,
    onDestroy() {
      unsub();
    }
  };
}

// node_modules/paneforge/dist/components/pane-resizer.svelte
var file3 = "node_modules\\paneforge\\dist\\components\\pane-resizer.svelte";
function create_fragment3(ctx) {
  let div;
  let resizeHandleAction_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[24].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  let div_levels = [
    { role: "separator" },
    { style: (
      /*style*/
      ctx[5]
    ) },
    { tabindex: (
      /*tabIndex*/
      ctx[3]
    ) },
    /*attrs*/
    ctx[8],
    /*$$restProps*/
    ctx[17]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { role: true, style: true, tabindex: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file3, 90, 0, 2716);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[25](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(resizeHandleAction_action = resizeHandleAction.call(null, div, {
            disabled: (
              /*disabled*/
              ctx[1]
            ),
            resizeHandler: (
              /*resizeHandler*/
              ctx[7]
            ),
            stopDragging: (
              /*stopDragging*/
              ctx[10]
            ),
            isDragging: (
              /*isDragging*/
              ctx[6]
            ),
            onDragging: (
              /*onDraggingChange*/
              ctx[2]
            )
          })),
          listen_dev(
            div,
            "keydown",
            /*handleKeydown*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "blur",
            /*blur_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focus",
            /*focus_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousedown",
            /*mousedown_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseup",
            /*stopDraggingAndBlur*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchcancel",
            /*stopDraggingAndBlur*/
            ctx[15],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchend",
            /*stopDraggingAndBlur*/
            ctx[15],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchstart",
            /*touchstart_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "separator" },
        (!current || dirty & /*style*/
        32) && { style: (
          /*style*/
          ctx2[5]
        ) },
        (!current || dirty & /*tabIndex*/
        8) && { tabindex: (
          /*tabIndex*/
          ctx2[3]
        ) },
        dirty & /*attrs*/
        256 && /*attrs*/
        ctx2[8],
        dirty & /*$$restProps*/
        131072 && /*$$restProps*/
        ctx2[17]
      ]));
      if (resizeHandleAction_action && is_function(resizeHandleAction_action.update) && dirty & /*disabled, resizeHandler, isDragging, onDraggingChange*/
      198)
        resizeHandleAction_action.update.call(null, {
          disabled: (
            /*disabled*/
            ctx2[1]
          ),
          resizeHandler: (
            /*resizeHandler*/
            ctx2[7]
          ),
          stopDragging: (
            /*stopDragging*/
            ctx2[10]
          ),
          isDragging: (
            /*isDragging*/
            ctx2[6]
          ),
          onDragging: (
            /*onDraggingChange*/
            ctx2[2]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let isDragging;
  let style;
  let attrs;
  const omit_props_names = ["disabled", "onDraggingChange", "tabIndex", "el", "id", "style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $groupId;
  let $direction;
  let $dragState;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pane_resizer", slots, ["default"]);
  let { disabled = false } = $$props;
  let { onDraggingChange = void 0 } = $$props;
  let { tabIndex = 0 } = $$props;
  let { el = null } = $$props;
  let { id: idFromProps = void 0 } = $$props;
  let { style: styleFromProps = void 0 } = $$props;
  const { methods: { registerResizeHandle, startDragging, stopDragging }, states: { direction, dragState, groupId } } = getCtx("PaneResizer");
  validate_store(direction, "direction");
  component_subscribe($$self, direction, (value) => $$invalidate(21, $direction = value));
  validate_store(dragState, "dragState");
  component_subscribe($$self, dragState, (value) => $$invalidate(22, $dragState = value));
  validate_store(groupId, "groupId");
  component_subscribe($$self, groupId, (value) => $$invalidate(20, $groupId = value));
  const resizeHandleId = generateId(idFromProps);
  let isFocused = false;
  let resizeHandler = null;
  function stopDraggingAndBlur() {
    const element3 = el;
    if (!element3)
      return;
    element3.blur();
    stopDragging();
    onDraggingChange?.(false);
  }
  onMount(() => {
    if (disabled) {
      $$invalidate(7, resizeHandler = null);
    } else {
      $$invalidate(7, resizeHandler = registerResizeHandle(resizeHandleId));
    }
  });
  function handleKeydown(event) {
    if (disabled || !resizeHandler || event.defaultPrevented)
      return;
    const resizeKeys = ["ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp", "End", "Home"];
    if (resizeKeys.includes(event.key)) {
      event.preventDefault();
      resizeHandler(event);
      return;
    }
    if (event.key !== "F6")
      return;
    event.preventDefault();
    const handles = getResizeHandleElementsForGroup($groupId);
    const index = getResizeHandleElementIndex($groupId, resizeHandleId);
    if (index === null)
      return;
    const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;
    const nextHandle = handles[nextIndex];
    nextHandle.focus();
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  const blur_handler = () => $$invalidate(4, isFocused = false);
  const focus_handler = () => $$invalidate(4, isFocused = true);
  const mousedown_handler = (e) => {
    e.preventDefault();
    startDragging(resizeHandleId, e);
    onDraggingChange?.(true);
  };
  const touchstart_handler = (e) => {
    e.preventDefault();
    startDragging(resizeHandleId, e);
    onDraggingChange?.(true);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("onDraggingChange" in $$new_props)
      $$invalidate(2, onDraggingChange = $$new_props.onDraggingChange);
    if ("tabIndex" in $$new_props)
      $$invalidate(3, tabIndex = $$new_props.tabIndex);
    if ("el" in $$new_props)
      $$invalidate(0, el = $$new_props.el);
    if ("id" in $$new_props)
      $$invalidate(18, idFromProps = $$new_props.id);
    if ("style" in $$new_props)
      $$invalidate(19, styleFromProps = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getResizeHandleElementIndex,
    getResizeHandleElementsForGroup,
    generateId,
    getCursorStyle,
    styleToString,
    onMount,
    getCtx,
    resizeHandleAction,
    disabled,
    onDraggingChange,
    tabIndex,
    el,
    idFromProps,
    styleFromProps,
    registerResizeHandle,
    startDragging,
    stopDragging,
    direction,
    dragState,
    groupId,
    resizeHandleId,
    isFocused,
    resizeHandler,
    stopDraggingAndBlur,
    handleKeydown,
    style,
    isDragging,
    attrs,
    $groupId,
    $direction,
    $dragState
  });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("onDraggingChange" in $$props)
      $$invalidate(2, onDraggingChange = $$new_props.onDraggingChange);
    if ("tabIndex" in $$props)
      $$invalidate(3, tabIndex = $$new_props.tabIndex);
    if ("el" in $$props)
      $$invalidate(0, el = $$new_props.el);
    if ("idFromProps" in $$props)
      $$invalidate(18, idFromProps = $$new_props.idFromProps);
    if ("styleFromProps" in $$props)
      $$invalidate(19, styleFromProps = $$new_props.styleFromProps);
    if ("isFocused" in $$props)
      $$invalidate(4, isFocused = $$new_props.isFocused);
    if ("resizeHandler" in $$props)
      $$invalidate(7, resizeHandler = $$new_props.resizeHandler);
    if ("style" in $$props)
      $$invalidate(5, style = $$new_props.style);
    if ("isDragging" in $$props)
      $$invalidate(6, isDragging = $$new_props.isDragging);
    if ("attrs" in $$props)
      $$invalidate(8, attrs = $$new_props.attrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$dragState*/
    4194304) {
      $:
        $$invalidate(6, isDragging = $dragState?.dragHandleId === resizeHandleId);
    }
    if ($$self.$$.dirty & /*disabled*/
    2) {
      $:
        if (disabled) {
          $$invalidate(7, resizeHandler = null);
        } else {
          $$invalidate(7, resizeHandler = registerResizeHandle(resizeHandleId));
        }
    }
    if ($$self.$$.dirty & /*$direction, styleFromProps*/
    2621440) {
      $:
        $$invalidate(5, style = styleToString({
          cursor: getCursorStyle($direction),
          "touch-action": "none",
          "user-select": "none",
          "-webkit-user-select": "none",
          "-webkit-touch-callout": "none"
        }) + styleFromProps);
    }
    if ($$self.$$.dirty & /*$direction, $groupId, isDragging, isFocused, disabled*/
    3145810) {
      $:
        $$invalidate(8, attrs = {
          "data-direction": $direction,
          "data-pane-group-id": $groupId,
          "data-active": isDragging ? "pointer" : isFocused ? "keyboard" : void 0,
          "data-enabled": !disabled,
          "data-pane-resizer-id": resizeHandleId,
          "data-pane-resizer": ""
        });
    }
    if ($$self.$$.dirty & /*style*/
    32) {
      $:
        console.log(style);
    }
  };
  return [
    el,
    disabled,
    onDraggingChange,
    tabIndex,
    isFocused,
    style,
    isDragging,
    resizeHandler,
    attrs,
    startDragging,
    stopDragging,
    direction,
    dragState,
    groupId,
    resizeHandleId,
    stopDraggingAndBlur,
    handleKeydown,
    $$restProps,
    idFromProps,
    styleFromProps,
    $groupId,
    $direction,
    $dragState,
    $$scope,
    slots,
    div_binding,
    blur_handler,
    focus_handler,
    mousedown_handler,
    touchstart_handler
  ];
}
var Pane_resizer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      disabled: 1,
      onDraggingChange: 2,
      tabIndex: 3,
      el: 0,
      id: 18,
      style: 19
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pane_resizer",
      options,
      id: create_fragment3.name
    });
  }
  get disabled() {
    throw new Error("<Pane_resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Pane_resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDraggingChange() {
    throw new Error("<Pane_resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDraggingChange(value) {
    throw new Error("<Pane_resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabIndex() {
    throw new Error("<Pane_resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabIndex(value) {
    throw new Error("<Pane_resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get el() {
    throw new Error("<Pane_resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set el(value) {
    throw new Error("<Pane_resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Pane_resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Pane_resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Pane_resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Pane_resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var pane_resizer_default = Pane_resizer;
export {
  pane_default as Pane,
  pane_group_default as PaneGroup,
  pane_resizer_default as PaneResizer
};
//# sourceMappingURL=paneforge.js.map
