import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export interface DocumentationUpdateRule {
    id: string;
    name: string;
    description: string;
    trigger: UpdateTrigger;
    condition: UpdateCondition;
    action: UpdateAction;
    enabled: boolean;
    priority: number;
}

export interface UpdateTrigger {
    type: 'file_change' | 'git_commit' | 'schedule' | 'manual';
    patterns?: string[]; // File patterns to watch
    schedule?: string; // Cron expression for scheduled updates
    events?: string[]; // Specific events to listen for
}

export interface UpdateCondition {
    filePatterns?: string[];
    changeTypes?: ('create' | 'modify' | 'delete')[];
    minChanges?: number;
    excludePatterns?: string[];
    customCondition?: string; // JavaScript expression
}

export interface UpdateAction {
    type: 'regenerate' | 'update_section' | 'add_entry' | 'custom';
    targetFiles: string[];
    template?: string;
    sectionId?: string;
    customScript?: string;
    variables?: { [key: string]: any };
}

export interface DocumentationFile {
    path: string;
    type: 'readme' | 'api' | 'changelog' | 'contributing' | 'other';
    lastUpdated: Date;
    autoGenerated: boolean;
    sections: DocumentationSection[];
    metadata: { [key: string]: any };
}

export interface DocumentationSection {
    id: string;
    title: string;
    content: string;
    startLine: number;
    endLine: number;
    autoGenerated: boolean;
    lastUpdated: Date;
}

export interface UpdateResult {
    success: boolean;
    message: string;
    filesUpdated: string[];
    errors: string[];
    timestamp: Date;
}

export interface ChangeAnalysis {
    files: ChangedFile[];
    summary: ChangeSummary;
    impact: ChangeImpact;
}

export interface ChangedFile {
    path: string;
    type: 'create' | 'modify' | 'delete';
    language: string;
    changes: CodeChange[];
    impact: 'low' | 'medium' | 'high';
}

export interface CodeChange {
    type: 'function' | 'class' | 'interface' | 'variable' | 'import' | 'export';
    name: string;
    action: 'added' | 'modified' | 'removed';
    line: number;
    description: string;
}

export interface ChangeSummary {
    totalFiles: number;
    newFiles: number;
    modifiedFiles: number;
    deletedFiles: number;
    newFunctions: number;
    modifiedFunctions: number;
    newClasses: number;
    modifiedClasses: number;
}

export interface ChangeImpact {
    apiChanges: boolean;
    breakingChanges: boolean;
    newFeatures: boolean;
    bugFixes: boolean;
    documentationNeeded: string[];
}

export class AutoDocumentationUpdater {
    private rules: Map<string, DocumentationUpdateRule> = new Map();
    private documentationFiles: Map<string, DocumentationFile> = new Map();
    private fileWatcher: vscode.FileSystemWatcher | undefined;
    private updateQueue: UpdateTask[] = [];
    private isProcessing = false;

    constructor(private context: vscode.ExtensionContext) {
        this.initializeDefaultRules();
        this.loadConfiguration();
        this.setupFileWatcher();
    }

    /**
     * 啟動自動更新系統
     */
    async start(): Promise<void> {
        console.log('啟動自動文檔更新系統');

        // 掃描現有文檔
        await this.scanDocumentationFiles();

        // 開始處理更新隊列
        this.processUpdateQueue();

        console.log('自動文檔更新系統已啟動');
    }

    /**
     * 停止自動更新系統
     */
    stop(): void {
        console.log('停止自動文檔更新系統');

        if (this.fileWatcher) {
            this.fileWatcher.dispose();
            this.fileWatcher = undefined;
        }

        this.isProcessing = false;
    }

    /**
     * 手動觸發文檔更新
     */
    async triggerUpdate(files?: string[]): Promise<UpdateResult> {
        console.log('手動觸發文檔更新', files);

        try {
            const changes = await this.analyzeChanges(files);
            const applicableRules = this.findApplicableRules(changes, 'manual');

            const results: UpdateResult[] = [];
            for (const rule of applicableRules) {
                const result = await this.executeRule(rule, changes);
                results.push(result);
            }

            return this.mergeResults(results);
        } catch (error) {
            return {
                success: false,
                message: `手動更新失敗: ${error}`,
                filesUpdated: [],
                errors: [String(error)],
                timestamp: new Date()
            };
        }
    }

    /**
     * 添加更新規則
     */
    addRule(rule: DocumentationUpdateRule): void {
        this.rules.set(rule.id, rule);
        this.saveConfiguration();
    }

    /**
     * 移除更新規則
     */
    removeRule(ruleId: string): void {
        this.rules.delete(ruleId);
        this.saveConfiguration();
    }

    /**
     * 獲取所有規則
     */
    getRules(): DocumentationUpdateRule[] {
        return Array.from(this.rules.values());
    }

    /**
     * 設置文件監視器
     */
    private setupFileWatcher(): void {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {return;}

        this.fileWatcher = vscode.workspace.createFileSystemWatcher(
            new vscode.RelativePattern(workspaceFolder, '**/*'),
            false, // Don't ignore creates
            false, // Don't ignore changes
            false  // Don't ignore deletes
        );

        this.fileWatcher.onDidCreate(uri => this.handleFileChange(uri, 'create'));
        this.fileWatcher.onDidChange(uri => this.handleFileChange(uri, 'modify'));
        this.fileWatcher.onDidDelete(uri => this.handleFileChange(uri, 'delete'));
    }

    /**
     * 處理文件變更
     */
    private async handleFileChange(uri: vscode.Uri, changeType: 'create' | 'modify' | 'delete'): Promise<void> {
        const filePath = uri.fsPath;

        // 檢查是否應該忽略此文件
        if (this.shouldIgnoreFile(filePath)) {
            return;
        }

        console.log(`文件變更: ${changeType} ${filePath}`);

        // 分析變更
        const changes = await this.analyzeChanges([filePath]);

        // 查找適用的規則
        const applicableRules = this.findApplicableRules(changes, 'file_change');

        // 添加到更新隊列
        for (const rule of applicableRules) {
            this.addToUpdateQueue({
                rule,
                changes,
                priority: rule.priority,
                timestamp: new Date()
            });
        }
    }

    /**
     * 分析代碼變更
     */
    private async analyzeChanges(files?: string[]): Promise<ChangeAnalysis> {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            throw new Error('沒有打開的工作區');
        }

        const changedFiles: ChangedFile[] = [];
        const summary: ChangeSummary = {
            totalFiles: 0,
            newFiles: 0,
            modifiedFiles: 0,
            deletedFiles: 0,
            newFunctions: 0,
            modifiedFunctions: 0,
            newClasses: 0,
            modifiedClasses: 0
        };

        // 如果沒有指定文件，掃描所有文件
        const filesToAnalyze = files || await this.getAllSourceFiles();

        for (const filePath of filesToAnalyze) {
            try {
                const changedFile = await this.analyzeFileChanges(filePath);
                if (changedFile) {
                    changedFiles.push(changedFile);
                    this.updateSummary(summary, changedFile);
                }
            } catch (error) {
                console.warn(`分析文件變更失敗: ${filePath}`, error);
            }
        }

        const impact = this.analyzeChangeImpact(changedFiles);

        return {
            files: changedFiles,
            summary,
            impact
        };
    }

    /**
     * 分析單個文件的變更
     */
    private async analyzeFileChanges(filePath: string): Promise<ChangedFile | null> {
        try {
            const content = await fs.promises.readFile(filePath, 'utf8');
            const language = this.getFileLanguage(filePath);

            // 簡化的代碼分析
            const changes = this.parseCodeChanges(content, language);

            if (changes.length === 0) {
                return null;
            }

            return {
                path: filePath,
                type: 'modify', // 簡化處理
                language,
                changes,
                impact: this.calculateFileImpact(changes)
            };
        } catch (error) {
            return null;
        }
    }

    /**
     * 解析代碼變更
     */
    private parseCodeChanges(content: string, language: string): CodeChange[] {
        const changes: CodeChange[] = [];
        const lines = content.split('\n');

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // 檢測函數定義
            if (this.isFunctionDefinition(line, language)) {
                const functionName = this.extractFunctionName(line, language);
                if (functionName) {
                    changes.push({
                        type: 'function',
                        name: functionName,
                        action: 'added', // 簡化處理
                        line: i + 1,
                        description: `函數 ${functionName}`
                    });
                }
            }

            // 檢測類定義
            if (this.isClassDefinition(line, language)) {
                const className = this.extractClassName(line, language);
                if (className) {
                    changes.push({
                        type: 'class',
                        name: className,
                        action: 'added', // 簡化處理
                        line: i + 1,
                        description: `類 ${className}`
                    });
                }
            }
        }

        return changes;
    }

    /**
     * 查找適用的規則
     */
    private findApplicableRules(changes: ChangeAnalysis, triggerType: string): DocumentationUpdateRule[] {
        const applicableRules: DocumentationUpdateRule[] = [];

        for (const rule of this.rules.values()) {
            if (!rule.enabled) {continue;}
            if (rule.trigger.type !== triggerType) {continue;}

            if (this.isRuleApplicable(rule, changes)) {
                applicableRules.push(rule);
            }
        }

        return applicableRules.sort((a, b) => b.priority - a.priority);
    }

    /**
     * 檢查規則是否適用
     */
    private isRuleApplicable(rule: DocumentationUpdateRule, changes: ChangeAnalysis): boolean {
        const condition = rule.condition;

        // 檢查文件模式
        if (condition.filePatterns) {
            const hasMatchingFile = changes.files.some(file =>
                condition.filePatterns!.some(pattern =>
                    this.matchPattern(file.path, pattern)
                )
            );
            if (!hasMatchingFile) {return false;}
        }

        // 檢查變更類型
        if (condition.changeTypes) {
            const hasMatchingChangeType = changes.files.some(file =>
                condition.changeTypes!.includes(file.type)
            );
            if (!hasMatchingChangeType) {return false;}
        }

        // 檢查最小變更數量
        if (condition.minChanges && changes.summary.totalFiles < condition.minChanges) {
            return false;
        }

        return true;
    }

    /**
     * 執行規則
     */
    private async executeRule(rule: DocumentationUpdateRule, changes: ChangeAnalysis): Promise<UpdateResult> {
        console.log(`執行規則: ${rule.name}`);

        try {
            const action = rule.action;
            const filesUpdated: string[] = [];

            for (const targetFile of action.targetFiles) {
                const result = await this.executeAction(action, targetFile, changes);
                if (result) {
                    filesUpdated.push(targetFile);
                }
            }

            return {
                success: true,
                message: `規則 ${rule.name} 執行成功`,
                filesUpdated,
                errors: [],
                timestamp: new Date()
            };
        } catch (error) {
            return {
                success: false,
                message: `規則 ${rule.name} 執行失敗: ${error}`,
                filesUpdated: [],
                errors: [String(error)],
                timestamp: new Date()
            };
        }
    }

    /**
     * 執行動作
     */
    private async executeAction(action: UpdateAction, targetFile: string, changes: ChangeAnalysis): Promise<boolean> {
        switch (action.type) {
            case 'regenerate':
                return await this.regenerateFile(targetFile, changes);
            case 'update_section':
                return await this.updateSection(targetFile, action.sectionId!, changes);
            case 'add_entry':
                return await this.addEntry(targetFile, changes);
            case 'custom':
                return await this.executeCustomAction(action.customScript!, targetFile, changes);
            default:
                throw new Error(`未知的動作類型: ${action.type}`);
        }
    }

    /**
     * 重新生成文件
     */
    private async regenerateFile(targetFile: string, changes: ChangeAnalysis): Promise<boolean> {
        // 實作文件重新生成邏輯
        console.log(`重新生成文件: ${targetFile}`);
        return true;
    }

    /**
     * 更新章節
     */
    private async updateSection(targetFile: string, sectionId: string, changes: ChangeAnalysis): Promise<boolean> {
        // 實作章節更新邏輯
        console.log(`更新章節: ${targetFile}#${sectionId}`);
        return true;
    }

    /**
     * 添加條目
     */
    private async addEntry(targetFile: string, changes: ChangeAnalysis): Promise<boolean> {
        // 實作條目添加邏輯
        console.log(`添加條目到: ${targetFile}`);
        return true;
    }

    /**
     * 執行自定義動作
     */
    private async executeCustomAction(script: string, targetFile: string, changes: ChangeAnalysis): Promise<boolean> {
        // 實作自定義腳本執行邏輯
        console.log(`執行自定義動作: ${targetFile}`);
        return true;
    }

    /**
     * 初始化默認規則
     */
    private initializeDefaultRules(): void {
        // API 變更自動更新 README
        this.rules.set('api-changes-readme', {
            id: 'api-changes-readme',
            name: 'API 變更更新 README',
            description: '當 API 發生變更時自動更新 README 文件',
            trigger: {
                type: 'file_change',
                patterns: ['**/*.ts', '**/*.js']
            },
            condition: {
                filePatterns: ['src/**/*'],
                changeTypes: ['modify'],
                minChanges: 1
            },
            action: {
                type: 'update_section',
                targetFiles: ['README.md'],
                sectionId: 'api'
            },
            enabled: true,
            priority: 5
        });

        // 新功能自動更新 CHANGELOG
        this.rules.set('new-features-changelog', {
            id: 'new-features-changelog',
            name: '新功能更新 CHANGELOG',
            description: '當添加新功能時自動更新 CHANGELOG',
            trigger: {
                type: 'git_commit'
            },
            condition: {
                changeTypes: ['create', 'modify']
            },
            action: {
                type: 'add_entry',
                targetFiles: ['CHANGELOG.md']
            },
            enabled: true,
            priority: 3
        });
    }

    // 輔助方法
    private shouldIgnoreFile(filePath: string): boolean {
        const ignorePatterns = [
            'node_modules',
            '.git',
            'dist',
            'build',
            '.vscode'
        ];
        return ignorePatterns.some(pattern => filePath.includes(pattern));
    }

    private getFileLanguage(filePath: string): string {
        const ext = path.extname(filePath).toLowerCase();
        const languageMap: { [key: string]: string } = {
            '.ts': 'typescript',
            '.js': 'javascript',
            '.py': 'python',
            '.java': 'java',
            '.cs': 'csharp'
        };
        return languageMap[ext] || 'unknown';
    }

    private isFunctionDefinition(line: string, language: string): boolean {
        const patterns: { [key: string]: RegExp[] } = {
            'typescript': [/function\s+\w+/, /\w+\s*\([^)]*\)\s*{/, /=>\s*{/],
            'javascript': [/function\s+\w+/, /\w+\s*\([^)]*\)\s*{/, /=>\s*{/],
            'python': [/def\s+\w+/]
        };
        return patterns[language]?.some(pattern => pattern.test(line)) || false;
    }

    private isClassDefinition(line: string, language: string): boolean {
        const patterns: { [key: string]: RegExp[] } = {
            'typescript': [/class\s+\w+/, /interface\s+\w+/],
            'javascript': [/class\s+\w+/],
            'python': [/class\s+\w+/]
        };
        return patterns[language]?.some(pattern => pattern.test(line)) || false;
    }

    private extractFunctionName(line: string, language: string): string | null {
        const match = line.match(/(?:function\s+)?(\w+)\s*\(/);
        return match ? match[1] : null;
    }

    private extractClassName(line: string, language: string): string | null {
        const match = line.match(/(?:class|interface)\s+(\w+)/);
        return match ? match[1] : null;
    }

    private calculateFileImpact(changes: CodeChange[]): 'low' | 'medium' | 'high' {
        if (changes.length > 10) {return 'high';}
        if (changes.length > 3) {return 'medium';}
        return 'low';
    }

    private updateSummary(summary: ChangeSummary, file: ChangedFile): void {
        summary.totalFiles++;
        if (file.type === 'create') {summary.newFiles++;}
        if (file.type === 'modify') {summary.modifiedFiles++;}
        if (file.type === 'delete') {summary.deletedFiles++;}

        for (const change of file.changes) {
            if (change.type === 'function' && change.action === 'added') {summary.newFunctions++;}
            if (change.type === 'function' && change.action === 'modified') {summary.modifiedFunctions++;}
            if (change.type === 'class' && change.action === 'added') {summary.newClasses++;}
            if (change.type === 'class' && change.action === 'modified') {summary.modifiedClasses++;}
        }
    }

    private analyzeChangeImpact(files: ChangedFile[]): ChangeImpact {
        return {
            apiChanges: files.some(f => f.changes.some(c => c.type === 'function' || c.type === 'class')),
            breakingChanges: false, // 簡化處理
            newFeatures: files.some(f => f.changes.some(c => c.action === 'added')),
            bugFixes: false, // 簡化處理
            documentationNeeded: ['README.md', 'API.md']
        };
    }

    private matchPattern(filePath: string, pattern: string): boolean {
        // 簡化的模式匹配
        return filePath.includes(pattern.replace('**/', '').replace('*', ''));
    }

    private async getAllSourceFiles(): Promise<string[]> {
        const files = await vscode.workspace.findFiles('**/*.{ts,js,py,java,cs}', '**/node_modules/**');
        return files.map(uri => uri.fsPath);
    }

    private async scanDocumentationFiles(): Promise<void> {
        // 掃描文檔文件
        const docFiles = await vscode.workspace.findFiles('**/*.md', '**/node_modules/**');
        for (const file of docFiles) {
            // 分析文檔文件結構
        }
    }

    private addToUpdateQueue(task: UpdateTask): void {
        this.updateQueue.push(task);
        this.updateQueue.sort((a, b) => b.priority - a.priority);
    }

    private async processUpdateQueue(): Promise<void> {
        if (this.isProcessing) {return;}
        this.isProcessing = true;

        while (this.updateQueue.length > 0) {
            const task = this.updateQueue.shift()!;
            try {
                await this.executeRule(task.rule, task.changes);
            } catch (error) {
                console.error('處理更新任務失敗:', error);
            }
        }

        this.isProcessing = false;
    }

    private mergeResults(results: UpdateResult[]): UpdateResult {
        const success = results.every(r => r.success);
        const filesUpdated = results.flatMap(r => r.filesUpdated);
        const errors = results.flatMap(r => r.errors);
        const messages = results.map(r => r.message);

        return {
            success,
            message: messages.join('; '),
            filesUpdated,
            errors,
            timestamp: new Date()
        };
    }

    private loadConfiguration(): void {
        // 載入配置
    }

    private saveConfiguration(): void {
        // 保存配置
    }

    /**
     * 清理資源
     */
    dispose(): void {
        this.stop();
    }
}

interface UpdateTask {
    rule: DocumentationUpdateRule;
    changes: ChangeAnalysis;
    priority: number;
    timestamp: Date;
}
